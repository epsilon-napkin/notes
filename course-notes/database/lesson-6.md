
---
title: 数据库原理及应用 Lesson 6
tag: [](/index.md)
---

### 6.1 问题的提出  
#### 6.1.1 关系模式的问题  
- **数据冗余**: 相同数据重复存储 (如系主任姓名).  
- **更新异常**: 修改冗余数据需更新多处 (如更换系主任).  
- **插入异常**: 无法插入部分信息 (如新系无学生时无法添加系信息).  
- **删除异常**: 删除数据时丢失关联信息 (如删除所有学生导致系信息丢失).  

**示例**:  
```sql
STUDENT(Sno, Sdept, Mname, Cno, Grade)  
F={Sno→Sdept, Sdept→Mname, (Sno,Cno)→Grade}
```

#### 6.1.2 数据依赖  
- **函数依赖 (FD)**: 属性间语义关联 (如 `Sno→Sdept`).  
- **多值依赖 (MVD)**: 更复杂的关联类型.  

#### 6.1.3 关系模式表示  
- 简化为 `R<U, F>`, 其中 `U` 为属性集, `F` 为函数依赖集.  

---

### 6.2 规范化理论  
#### 6.2.1 函数依赖  
1. **完全函数依赖**: `X→Y` 且 `X` 的任意真子集不能决定 `Y` (如 `(Sno,Cno)→Grade`).  
2. **部分函数依赖**: `X→Y` 但 `Y` 不完全依赖 `X` (如 `(Sno,Cno)→Sdept`).  
3. **传递函数依赖**: `X→Y→Z` 且 `Y↛X` (如 `Sno→Sdept→Mname`).  

#### 6.2.2 码  
- **候选码**: 最小属性组能唯一标识元组 (如 `(Sno,Cno)`).  
- **外码**: 非本关系码, 但为其他关系码 (如 `SC` 中的 `Sno`).  

#### 6.2.3 范式  
- **1NF**: 属性不可再分 (原子性).  
- **2NF**: 消除非主属性对码的部分函数依赖.  
- **3NF**: 消除非主属性对码的传递函数依赖.  
- **BCNF**: 消除主属性对码的部分和传递函数依赖.  

**规范化过程**:  
```
1NF → 消除部分依赖 → 2NF → 消除传递依赖 → 3NF → BCNF → 4NF
```

#### 6.2.4 1NF 示例  
- **问题**: 数据冗余和操作异常.  
- **解决**: 分解为 `SC(Sno,Cno,Grade)` 和 `S-L(Sno,Sdept,Sloc)`.  

#### 6.2.5 2NF 示例  
- **问题**: 非主属性 (`Sdept`, `Sloc`) 部分依赖码 `(Sno,Cno)`.  
- **解决**: 分解为 `SC(Sno,Cno,Grade)` 和 `S-L(Sno,Sdept,Sloc)`.  

#### 6.2.6 3NF 示例  
- **问题**: `Sloc` 传递依赖于 `Sno` (`Sno→Sdept→Sloc`).  
- **解决**: 分解为 `S-D(Sno,Sdept)` 和 `D-L(Sdept,Sloc)`.  

#### 6.2.7 规范化小结  
- **目标**: 减少冗余, 避免异常.  
- **平衡**: 并非范式越高越好, 需结合实际需求.  

---

### 6.5 小结  
- **工具性**: 规范化理论指导数据库设计, 需灵活应用.  
- **关键步骤**:  
  1. 分析函数依赖.  
  2. 逐步分解至目标范式.  
  3. 验证分解后的模式是否满足应用需求.  

**示例分解流程**:  
```
STUDENT(Sno,Sdept,Mname,Cno,Grade)  
→ 2NF: SC(Sno,Cno,Grade) + S-L(Sno,Sdept,Sloc)  
→ 3NF: S-D(Sno,Sdept) + D-L(Sdept,Sloc)
```