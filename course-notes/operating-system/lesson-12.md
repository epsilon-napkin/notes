
---
title: 操作系统 Lesson 12
tag: [](/index.md)
---

<style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>

### 连续分配存储管理⽅式

连续分配⽅式是最早出现的⼀种存储器分配⽅式, 曾被⼴泛应⽤于上世纪 60~80 年代的 OS 中, 该分配⽅式为⼀个⽤户程序分配⼀个连续的内存空间, 即程序中代码或数据的逻辑地址相邻, 体现在内存空间分配时物理地址的相邻. 连续分配 ⽅ 式可分为四类: 单⼀连续分配、 固定分区分配、 动态分区分配以及动态可重定位分区分配算法四种⽅式.

[](/408/operating-system/单⼀连续分配.md#:embed)
[](/408/operating-system/固定分区分配.md#:embed)
[](/408/operating-system/动态分区.md#:embed)

### 动态可重定位分区

动态分区分配方式 + 紧凑. 

---

### ⾸次适应算法

在分配内存时, 从链⾸开始顺序查找, 直⾄找到⼀个⼤⼩能满⾜要求的空闲分区为⽌. 然后再按照作业的⼤⼩, 从该分区中划出⼀块内存空间, 分配给请求者, 余下的空闲分区仍留在空闲链中. 若从链⾸直⾄链尾都不能找到⼀个能满⾜要求的分区, 则表明系统中已没有⾜够⼤的内存分配给该进程, 内存分配失败, 返回. 该算法倾向于优先利⽤内存中低址部分的空闲分区, 从⽽ *保留了⾼址部分的⼤空闲区*. 这为以后到达的⼤作业分配⼤的内存空间创造了条件. 其缺点是低址部分不断被划分, *会留下许多难以利⽤的、很⼩的空闲分区*, 称为碎⽚.⽽每次查找又都是 *从低址部分开始* 的, 这⽆疑又会 *增加查找可⽤空闲分区时的开销*.

### 循环⾸次适应算法

为避免低址部分留下许多很⼩的空闲分区, 以及減少查找可⽤空闲分区的开销, 循环⾸次适应算法在为进程分配内存空间时, 不再是每次都从链⾸开始查找,⽽是从上次找到的空闲分区的下⼀个空闲分区开始查找, 直⾄找到⼀个能满⾜要求的空闲分区, 从中划出⼀块与请求⼤⼩相等的内存空间分配给作业. 为实现该算法, 应设置⼀起始查寻指针,⽤于指⽰下⼀次起始查寻的空闲分区, 并采⽤循环查找⽅式, 即如果最后⼀个 (链尾) 空闲分区的⼤⼩仍不能满⾜要求, 则应返回到第⼀个空闲分区, ⽐较其⼤⼩是否满⾜要求. 找到后, 应调整起始查寻指针. 该算法能使内存中的 *空闲分区分布得更均匀*, 从⽽ *减少了查找空闲分区时的开销*, 但这样会 *缺乏⼤的空闲分区*.

### 最佳适应算法

所谓 “最佳” 是指, 每次为作业分配内存时, 总是把能满⾜要求、 又是最⼩的空闲分区分配给作业, 避免 "⼤材⼩⽤". 为了加速寻找, 该算法要求将所有的空闲分区按其容量以从⼩到⼤的顺序形成⼀空闲分区链. 这样, 第⼀次找到的能满⾜要求的空闲区必然是最佳的. 孤⽴地看, 最佳适应算法似乎是最佳的, 然⽽在宏观上却不⼀定. 因为每次分配后所切割下来的 *剩余部分总是最⼩的*, 这样, 在存储器中会 *留下许多难以利⽤的碎⽚*. 

### 最坏适应算法

最坏适应分配算法选择空闲分区的策略正好与最佳适应算法相反: 它在扫描整个空闲分区表或链表时, 总是挑选⼀个最⼤的空闲区, 从中分割⼀部分存储空间给作业使⽤. 它的优点是可使剩下的空闲区不⾄于太⼩, *产⽣碎⽚的可能性最⼩*, 对中、⼩作业有利, 但 *可能导致缺乏大的空闲区*. 同时, 最坏适应分配算法查找效率很⾼, 该算法要求, 将所有的空闲分区,按其容量以从⼤到⼩的顺序形成⼀空闲分区链, 查找时, 只要看第⼀个分区能否满⾜作业要求即可. 


$\textbf{Example.}$ 

| 请求队列 | ⾸次适应算法 |
| - | - |
| 初始 | 10 4 20 18 7 9 12 15 |
| 12KB | 10 4 *8* $~$ 18 7 9 12 15 |
| 10KB | *0* $~$ 4 8 $~$ 18 7 9 12 15  |
| 9KB | 0 $~$ 4 8 $~$ *9* $~$ 7 9 12 15  |


$\textbf{Example.}$ 

| 请求队列 | 循环⾸次适应算法 |
| - | - |
| 初始 | 10 4 20 18 7 9 12 15 |
| 12KB | 10 4 *8* $~$ 18 7 9 12 15 |
| 10KB | 10 4 8 $~$ *8* $~$ 7 9 12 15  |
| 9KB | 10 4 8 $~$ 8 $~$ 7 *0* 12 15  |

$\textbf{Example.}$ 

| 请求队列 | 最佳适应算法 |
| - | - |
| 初始 | 10 4 20 18 7 9 12 15 |
| 12KB | 10 4 20 18 7 9 *0* $~$ 15 |
| 10KB | *0* $~$ 4 20 18 7 9 0 $~$ 15  |
| 9KB | 0 $~$ 4 20 18 7 *0* 0 $~$ 15  |


$\textbf{Example.}$ 

| 请求队列 | 最坏适应算法 |
| - | - |
| 初始 | 10 4 20 18 7 9 12 15 |
| 12KB | 10 4 *8* $~$ 18 7 9 12 15 |
| 10KB | 10 4 8 $~$ *8* $~$ 7 9 12 15 |
| 9KB | 10 4 8 $~$ 8 $~$ 7 9 12 6 |

---

### 习题

用可变分区方式管理内存时, 假定内存中按地址顺序依次有 5 个空闲区, 大小为 32、 10、 5、 228、 100, 单位为 KB, 现有 5 个作业, 各需内存 11、 10、 108、 28、 115, 若采用首次适用分配算法能全部装入吗? 怎样才能装入?

<div>

| 请求队列 | ⾸次适应算法 |
| - | - |
| 初始 | 32 10 5 228 100 |
| 11 | *21* 10 5 228 100 |
| 10 | *11* 10 5 228 100 |
| 108 | 11 10 5 *120* 100 |
| 28 | 11 10 5 *92* 100 |
| 115 | 失败 |

因为失败的原因是缺乏大分区, 所以我们考虑最佳适应算法. 如下所示. 

| 请求队列 | 最佳适应算法 |
| - | - |
| 初始 | 32 10 5 228 100 |
| 11 | *21* 10 5 228 100 |
| 10 | 21 *0* 5 228 100 |
| 108 | 21 0 5 *120* 100 |
| 28 | 21 0 5 120 *72* |
| 115 | 21 0 5 *5* 72 |

</div>