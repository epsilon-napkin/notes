<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>计算机网络</title><link rel="stylesheet" href="/main.css">
<link rel="stylesheet" href="/typst.css"><style>
  .katex .mfrac .frac-line {
    font-size: 1.25em;
  }

  li p {
    margin: 0;
  }

  a.link.local,
  .link.local a {
    box-shadow: none;
    text-decoration-line: underline;
    text-decoration-style: dotted;
    color: rgb(16, 180, 158);
  }

  table {
    border-collapse: collapse;
  }

  table th {
    text-align: left;
  }

  table th,
  table td {
    padding: 0.4em;
    border: 1px solid #ccc;
  }

  blockquote {
    margin: 0.5em;
    padding: 0.5em;
    outline: 1px solid #ccc;
    border-radius: 0.2em;
    font-style: normal;
  }

  blockquote p {
    margin: 0;
  }

  hint {
    color: gray;
  }

  em {
    color: rgb(249, 117, 131);
    font-style: normal;
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&amp;family=Source+Sans+3:ital,wght@0,200..900;1,200..900&amp;family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

<style>
body {
  font-family: "Inria Sans", "Source Sans", sans-serif;
}

pre,
code {
  font-family: "Source Code Pro", monospace;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Inria Sans", sans-serif;
}

nav {
  font-family: "Inria Sans", sans-serif;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js"
  integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script></head><body><header class="header"><nav class="nav"><div class="logo"><span onclick="window.location.href='/index.html'" title="索引">« 索引</span></div></nav></header><div id="grid-wrapper"><article><section class="block" data-taxon=""><details open><summary id="408-network-index"><header><h1><span class="taxon"></span>计算机网络 <a class="slug" href="/408/network/index.html">[network]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/index.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-overview"><header><h1><span class="taxon"></span>概述 <a class="slug" href="/408/network/overview.html">[overview]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/overview.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li><p>网络把许多计算机连接在一起, 而互连网则把许多网络通过一些路由器连接在一起. 与网络相连的计算机常称为主机.</p>
</li>
<li><p>互联网的拓扑结构虽然非常复杂, 并且在地理上覆盖了全球, 但从其工作方式上看可以划分为:</p>
<ul>
<li>边缘部分: 由所有连接在互联网上的主机组成, 用户直接使用.</li>
<li>核心部分: 由大量网络和连接这些网络的路由器组成, 为边缘部分提供服务.</li>
</ul>
</li>
<li><p>在⽹络边缘的端系统之间的通信⽅式通常可划分为两⼤类: 客户-服务器⽅式 (C/S⽅式) 和对等⽅式 (P2P ⽅式).</p>
</li>
<li><p>电路交换的三个阶段: 建立连接, 通话, 释放连接.</p>
</li>
</ul>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-performance"><header><h1><span class="taxon"></span>计算机网络的性能 <a class="slug" href="/408/network/performance.html">[performance]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/performance.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\str#1{\footnotesize{#1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$
$\gdef\type#1{~:~\texttt{#1}}$</p>
<p>计算机网络的性能指标主要包括:</p>
<ul>
<li>速率</li>
<li>带宽</li>
<li>吞吐率</li>
<li>时延</li>
<li>时延带宽积</li>
<li>往返时间 RTT</li>
<li>利用率</li>
</ul>
<p>吞吐量 [throughput] 表示在单位时间内通过某个网络 (或信道、接口) 的数据量. 吞吐量更经常地用于对现实世界中的网络的一种测量, 以便知道实际上到底有多少数据量能够通过网络. 吞吐量受网络的带宽或网络的额定速率的限制.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-delay"><header><h1><span class="taxon"></span>时延 <a class="slug" href="/408/network/delay.html">[delay]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/delay.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\str#1{{\footnotesize #1}}$
$\gdef\type#1{~:~\texttt{#1}}$</p>
<p>时延 [delay / latency] 是指数据 (一个报文或分组, 甚至比特) 从网络或链路的一端传送到另一端所需的时间. 有时也称为延迟或迟延. 网络中的时延由以下几个不同的部分组成:</p>
<ol>
<li><p>发送时延 $~ = ~ \dfrac{\str{数据帧长度; 数据块长度} ~ l \type{bit}}{\str{发送速率; 信道带宽} ~ v \type{bit/s}}$</p>
</li>
<li><p>传播时延 $~ = ~ \dfrac{\str{信道长度} ~ l \type{m}}{\str{信号在信道上的传播速率} ~ v \type{m/s}}$</p>
</li>
<li><p>处理时延   主机或路由器在收到分组时要花费⼀定的时间进⾏处理, 例如分析分组的⾸部、 从分组中提取数据部分、 进⾏差错检验或查找转发表等, 这就产⽣了处理时延.</p>
</li>
<li><p>排队时延   分组在经过⽹络传输时, 要经过许多路由器. 但分组在进⼊路由器后要先在输⼊队列中排队等待处理. 在路由器确定了转发接⼜后, 还要在输出队列中排队等待转发. 这就产⽣了排队时延. 排队时延的长短往往取决于⽹络当时的通信量. 当⽹络的通信量很⼤时会发⽣队列溢出, 使分组丢失, 这相当于排队时延为⽆穷⼤.</p>
</li>
</ol>
</details></section>
<span class="link local"><a href="/408/network/utilization-rate.html" title="利用率 [408/network/utilization-rate]">利用率</a></span></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-protocol"><header><h1><span class="taxon"></span>协议与划分层次 <a class="slug" href="/408/network/protocol.html">[protocol]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/protocol.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>计算机网络中的数据交换必须遵守事先约定好的规则.
这些规则明确规定了所交换的数据的格式以及有关的同步问题 (同步含有时序的意思). 网络协议 (Network Protocol), 简称为协议, 是为进行网络中的数据交换而建立的规则、标准或约定.</p>
<blockquote>
<p>协议是水平的, 服务是垂直的.</p>
</blockquote>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-layered-network-model"><header><h1><span class="taxon"></span>三种体系结构 <a class="slug" href="/408/network/layered-network-model.html">[layered-network-model]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/layered-network-model.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\str#1{\footnotesize{#1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$</p>
<blockquote>
<p><span class="link local"><a href="/408/network/application-layer.html" title="应用层 [408/network/application-layer]">应用层</a></span> $\to$ <span class="link local"><a href="/408/network/transport-layer.html" title="运输层 [408/network/transport-layer]">运输层</a></span> $\to$ <span class="link local"><a href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">网络层</a></span> $\to$ <span class="link local"><a href="/408/network/data-link-layer.html" title="数据链路层 [408/network/data-link-layer]">数据链路层</a></span> $\to$ <span class="link local"><a href="/408/network/physical-layer.html" title="物理层 [408/network/physical-layer]">物理层</a></span></p>
</blockquote>
<table><thead><tr><th>OSI 的体系结构</th><th>(四层) TCP/IP 的体系结构</th><th>五层协议的体系结构</th></tr></thead><tbody>
<tr><td>7	应用层</td><td>应用层 (应用层协议如	DNS, HTTP, SMTP, RTP 等)</td><td>5 应用层</td></tr>
<tr><td>6 表示层</td><td></td><td></td></tr>
<tr><td>5 会话层</td><td></td><td></td></tr>
<tr><td>4 运输层</td><td>运输层 (TCP 或UDP)</td><td>4 运输层</td></tr>
<tr><td>3 网络层</td><td>网际层 IP</td><td>3 网络层</td></tr>
<tr><td>2 数据链路层</td><td>网络接口层 (这一层并没有具体内容)</td><td>2 数据链路层</td></tr>
<tr><td>1 物理层</td><td>$\hint{网络接口层}$</td><td>1 物理层</td></tr>
</tbody></table>
</details></section></p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-physical-layer"><header><h1><span class="taxon"></span>物理层 <a class="slug" href="/408/network/physical-layer.html">[physical-layer]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/physical-layer.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-physical-layer-0001"><header><h1><span class="taxon"></span>常用术语 <a class="slug" href="/408/network/physical-layer-0001.html">[physical-layer-0001]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/physical-layer-0001.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>数据 [data] — 运送消息的实体.</li>
<li>信号 [signal] — 数据的电气的或电磁的表现.</li>
<li>模拟信号 [analogous signal] — 代表消息的参数的取值是连续的.</li>
<li>数字信号 [digital signal] — 代表消息的参数的取值是离散的.</li>
<li>码元 [code] — 在使用时间域 (或简称为时域) 的波形表示数字信号时, 代表不同离散数值的基本波形.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-physical-layer-0002"><header><h1><span class="taxon"></span>有关信道的几个基本概念 <a class="slug" href="/408/network/physical-layer-0002.html">[physical-layer-0002]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/physical-layer-0002.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>信道 — 一般用来表示向某一个方向传送信息的媒体.</li>
<li>单向通信 (单工通信) — 只能有一个方向的通信而没有反方向的交互.</li>
<li>双向交替通信 (半双工通信) — 通信的双方都可以发送信息, 但不能双方同时发送 (当然也就不能同时接收).</li>
<li>双向同时通信 (全双工通信) — 通信的双方可以同时发送和接收信息.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-modulation"><header><h1><span class="taxon"></span>调制 <a class="slug" href="/408/network/modulation.html">[modulation]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/modulation.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>调制分为两大类:</p>
<ul>
<li><p>基带调制: 仅对基带信号的波形进行变换, 使它能够与信道特性相适应. 变换后的信号仍然是基带信号. 把这种过程称为编码 [coding].</p>
</li>
<li><p>带通调制: 使用载波 [carrier] 进行调制, 把基带信号的频率范围搬移到较高的频段, 并转换为模拟信号, 这样就能够更好地在模拟信道中传输 (即仅在一段频率范围内能够通过信道).</p>
<ul>
<li>带通信号: 经过载波调制后的信号.</li>
</ul>
</li>
</ul>
<h3>基本的带通调制方法</h3>
<ul>
<li>调幅 (AM): 载波的振幅随基带数字信号而变化.</li>
<li>调频 (FM): 载波的频率随基带数字信号而变化.</li>
<li>调相 (PM): 载波的初始相位随基带数字信号而变化.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-encoding-method"><header><h1><span class="taxon"></span>数字信号编码方法 <a class="slug" href="/408/network/encoding-method.html">[encoding-method]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/encoding-method.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
img {
  border-radius: 0.2em; 
  width: 400px;
}
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
</style>
<div style="text-align: center;">
<p><img src="/assets/数字信号编码方法.jpg" title="" alt=""></p>
</div>
<ul>
<li>不归零制: 正电平代表 1, 负电平代表 0.</li>
<li>归零制: 正脉冲代表 1, 负脉冲代表 0.</li>
<li>曼彻斯特编码: 位周期中心的向上跳变代表 0, 位周期中心的向下跳变代表 1. <em>但也可反过来定义</em>.</li>
<li>差分曼彻斯特编码: 在每一位的中心处始终都有跳变, 位开始边界有跳变代表 0, 而位开始边界没有跳变代表 1.</li>
</ul>
<p>从信号波形中可以看出, 曼彻斯特 [Manchester] 编码产生的信号频率比不归零制高. 从自同步能力来看, 不归零制不能从信号波形本身中提取信号时钟频率, 这叫作没有自同步能力, 而曼彻斯特编码具有自同步能力.</p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-maximum-capacity"><header><h1><span class="taxon"></span>信道的极限容量 <a class="slug" href="/408/network/maximum-capacity.html">[maximum-capacity]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/maximum-capacity.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>从概念上讲, 限制码元在信道上的传输速率的因素有以下两个:</p>
<ul>
<li>信道能够通过的频率范围</li>
<li>信噪比</li>
</ul>
<h4>奈氏准则</h4>
<blockquote>
<p>理想信道, 极限码元传输率 $2W$ 波特, 低信道下的极限数据传输率 <code>(b/s)</code> $=2W \log_2 V$.
$W$ 是理想低通道的带宽, 单位为 <code>Hz</code>. $V$ 表示每个码元离散电平的数目.</p>
</blockquote>
<ol>
<li>码元传输的速率是有上限的, 超过次上限, 就会出现码间串扰问题, 使接收端不能完全正确识别码元.</li>
<li>信道的频带越宽, 可更高的速率进行码元的有效传输.</li>
<li>码元传输速率受奈氏准则制约, 要提高数据传输速率, 需要使每个码元携带更多比特的信息量, 需要采用多元制.</li>
</ol>
<h4>香农定理</h4>
<blockquote>
<p>带宽受限且高斯白噪声干扰的信道的极限数据传输速率 $C = W \log_2(1+S/N)$.
$S/N$ 为信噪比, 即信号平均功率与噪声平均功率之比, 位为分贝 <code>(dB)</code>. 信噪比 <code>(dB)</code> $= 10 \log_{10}(S/N)$.</p>
</blockquote>
<ol>
<li>信道的带宽或信道的信噪比越大, 信息的极限传输速率就越高.</li>
<li>只要信息传输速率低于信道的极限信息传输速率, 就一定存在某种方法来实现无差别的传输.</li>
<li>对一定的传输带宽和信噪比, 信息传输速率上限是一定的; 若信道带宽 $W$ 或信噪比 $S/N$ 没有上限, 则信道的极限信息传输速率 $C$ 也没有上限.</li>
<li>码元传输的速率越高, 或信号传输的距离越远, 或噪声干扰越大, 或传输媒体质量越差, 在接收端的波形的失真就越严重.</li>
</ol>
<h4>补充</h4>
<p style="text-align: center;"><img src="../../assets/奈⽒准则和⾹农公式.jpg" style="border-radius: 0.2em; width: 500px;"></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-transmission"><header><h1><span class="taxon"></span>信号传输方式 <a class="slug" href="/408/network/transmission.html">[transmission]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/transmission.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ol>
<li><p>基带传输: 计算机内部或在相邻设备之间近距离传输, 可以不经过调制就在信道上直接进行的传输方式.</p>
<ul>
<li>数字基带传输就是在信道中直接传输数字信号, 传输媒体的整个带宽都被基带信号占用, 双向的传输信息.</li>
</ul>
</li>
<li><p>频带传输: 对数字信号特定的频率的载波进行调制, 将其变成适合于传送的信号后再进行传输.</p>
<ul>
<li>远距离传输或无线传输时, 数字信号必须用频带传输技术进行传输, 解决了电话系统传输数字信号的问题, 实现多路复用, 提高传输信道的利用率.</li>
</ul>
</li>
<li><p>宽带传输: 借助频带传输, 可将链路容量分解成两个或多个信道, 每个信道可以携带不同的信号.</p>
<ul>
<li>宽带传输的所有信道能同时互不干扰地发送信号, 链路容量大大增加.</li>
</ul>
</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-multiplexing"><header><h1><span class="taxon"></span>信道复用技术 <a class="slug" href="/408/network/multiplexing.html">[multiplexing]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/multiplexing.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\spaces#1{~ #1 ~}$</p>
<p>信道复用技术可分为:</p>
<ul>
<li>频分复用、时分复用和统计时分复用</li>
<li>波分复用</li>
<li>码分复用</li>
</ul>
<h4>频分复用</h4>
<ul>
<li>将整个带宽分为多份, 用户在分配到一定的频带后, 在通信过程中自始至终都占用这个频带.</li>
<li>频分复用的所有用户在同样的时间占用不同的带宽资源 (注意这里的 “带宽” 是频率带宽而不是数据的发送速率).</li>
</ul>
<h4>时分复用</h4>
<ul>
<li>时分复用则是将时间划分为一段段等长的时分复用帧 (TDM 帧).</li>
<li>每一个时分复用的用户在每一个 TDM 帧中占用固定序号的时隙.每一个用户所占用的时隙是周期性地出现 (其周期就是 TDM 帧的长度).</li>
<li>TDM 信号也称为等时 (isochronous) 信号.</li>
<li>时分复用的所有用户是在不同的时间占用同样的频带宽度.</li>
<li>时分复用可能会造成线路资源的浪费.</li>
</ul>
<h4>统计时分复用</h4>
<ul>
<li>STDM 帧不是固定分配时隙, 而是按需动态地分配时隙. 因此统计时分复用可以提高线路的利用率.</li>
</ul>
<h4>波分复用</h4>
<h4>码分复用</h4>
<ul>
<li>常用的名词是码分多址 CDMA (Code Division Multiple Access).</li>
<li>各用户使用经过特挑选的不同码型, 因此彼此不会造成干扰.</li>
<li>这种系统发送的信号有很强的抗干扰能力, 其频谱类似于白噪声, 不易被敌人发现.</li>
</ul>
<p>$$
\begin{gathered}
S \cdot T = 0, \quad S \cdot S = 1, \quad S \cdot \bar{S} = -1 \\
\Darr \\
S \cdot (S+T) = 1, \quad S \cdot (\bar{S}+T) = -1 \\
\Darr \quad\quad \qquad \quad\quad \Darr \\
S=1 \quad \qquad \quad S=0
\end{gathered}
$$</p>
<p>$\therefore$ 码片 $\cdot$ 收到的信号 $=\begin{cases} ~~~0 \spaces\Rarr \text{none} \\ ~~~1 \spaces\Rarr 1 \\ -1 \spaces\Rarr 0 \end{cases}$</p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-data-link-layer"><header><h1><span class="taxon"></span>数据链路层 <a class="slug" href="/408/network/data-link-layer.html">[data-link-layer]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/data-link-layer.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
</style>
<p>可靠传输协议将在 <span class="link local"><a href="/408/network/transport-layer.html" title="运输层 [408/network/transport-layer]">运输层</a></span> 中讨论. 本章介绍的数据链路层协议都不是可靠传输的协议. 数据链路层属于计算机网络的低层, 其使用的信道与相应的协议主要有以下两种类型:</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-point-to-point"><header><h1><span class="taxon"> 1. </span>点对点 <a class="slug" href="/408/network/point-to-point.html">[point-to-point]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/point-to-point.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><em>帧</em> 是点对点信道的数据链路层的协议数据单元. 这种信道使用一对一的点对点通信方式. 相应的点对点协议 PPP 应满足下列需求:</p>
<ol>
<li>简单 — 这是首要的要求.</li>
<li>封装成帧 — 必须规定特殊的字符作为帧定界符.</li>
<li>透明性 — 必须保证数据传输的透明性.</li>
<li>多种网络层协议 — 能够在同一条物理链路上同时支持多种网络层协议.</li>
<li>多种类型链路 — 能够在多种类型的链路上运行.</li>
<li>差错检测 — 能够对接收端收到的帧进行检测, 并立即丢弃有差错的帧.</li>
<li>检测连接状态 — 能够及时自动检测出链路是否处于正常工作状态.</li>
<li>最大传送单元 — 必须对每一种类型的点对点链路设置 <span class="link local"><a href="/408/network/maximum-transmission-unit.html" title="最⼤传送单元 [408/network/maximum-transmission-unit]">最大传送单元 MTU</a></span> 的标准默认值, 促进各种实现之间的互操作性.</li>
<li>网络层地址协商 — 必须提供一种机制使通信的两个网络层实体能够通过协商知道或能够配置彼此的网络层地址.</li>
<li>数据压缩协商 — 必须提供一种方法来协商使用数据压缩算法.</li>
</ol>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-point-to-point-1"><header><h1><span class="taxon"></span>PPP 协议的组成 <a class="slug" href="/408/network/point-to-point-1.html">[point-to-point-1]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/point-to-point-1.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p style="text-align: center;"><img src="../../assets/PPP 帧的格式.png" style="border-radius: 0.2em; width: 400px;"></p>
<p>⾸部的第⼀个字段和尾部的第⼆个字段都是标志字段 $\text{F}$ (Flag), 规定为 <code>Ox7E</code>, ⼗六进制的 <code>7E</code> 的⼆进制表⽰是 <code>01111110</code>. 标志字段表⽰⼀个帧的开始或结束. 因此标志字段就是 PPP 帧的定界符. 连续两帧之间只需要⽤⼀个标志字段. 如果出现连续两个标志字段, 就表⽰这是⼀个空帧, 应当丢弃.</p>
<p>⾸部中的地址字段 $\text{A}$ 规定 <code>OxFF</code> 即 <code>11111111</code>, 控制字段 $\text{C}$ 规定为 <code>0x03</code> 即 <code>00000011</code>. 最初曾考虑以后再对这两个字段的值进⾏其他定义, 但⾄今也没有给出. 可见这两个字段实际上并没有携带 PPP 帧的信息.</p>
<p>PPP ⾸部的第四个字段是 2 字节的协议字段. 当协议字段为 <code>0x0021</code> 时, PPP 帧的信息字段就是 IP 数据报. 若为 <code>OxCO21</code>, 则信息字段是 PPP 链路控制协议 LCP 的数据,⽽ <code>0x8021</code> 表⽰这是⽹络层的控制数据. 信息字段的长度是可变的, 不超过 <span class="link local"><a href="/408/network/maximum-transmission-unit.html" title="最⼤传送单元 [408/network/maximum-transmission-unit]">1500 字节</a></span>. 尾部中的第⼀个字段 (2 字节) 是使⽤ CRC 的帧检验序列 FCS.</p>
</details></section></p>
<p>$\textbf{Remark.}$ FCS [Frame Check Sequence] 帧检验序列.</p>
<ol>
<li>字节填充. <code>7D 5[X]</code> $\lrarr$ <code>7[X]</code>, <code>[X] = D, E</code>.</li>
<li>零⽐特填充. 每 5 个 <code>1</code> 插入 <code>0</code> .</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-broadcast"><header><h1><span class="taxon"> 2. </span>广播 <a class="slug" href="/408/network/broadcast.html">[broadcast]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/broadcast.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\str#1{{\footnotesize #1}}$</p>
<p>这种信道使用一对多的广播通信方式, 因此过程比较复杂. 广播信道上连接的主机很多, 因此必须使用专用的共享信道协议来协调这些主机的数据发送.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-csma-cd"><header><h1><span class="taxon"></span>载波监听多点接⼊ / 碰撞检测 <a class="slug" href="/408/network/csma-cd.html">[csma-cd]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/csma-cd.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>CSMA / CD 的意思是 “载波监听多点接⼊ / 碰撞检测” [Carrier Sense Multiple Access with Collision Detection], 其中:</p>
<ul>
<li>“多点接入” 表示许多计算机以多点接入的方式连接在一根总线上.</li>
<li>“载波监听” 是指每一个站在发送数据之前先要检测一下总线上是否有其他计算机在发送数据, 如果有, 则暂时不要发送数据, 以免发生碰撞.</li>
<li>“碰撞检测” 是适配器边发送数据边检测信道上的信号电压的变化情况 (大小).</li>
</ul>
<p>$\textbf{Remark.}$ 总线上并没有什么 “载波”. 因此, “载波监听” 就是用电子技术检测总线上有没有其他计算机发送的数据信号.</p>
<p>$\textbf{Remark.}$ 当两个或⼏个站同时在总线上发送数据时, 总线上的信号电压变化幅度将会增⼤ (互相叠加). 当适配器检测到的信号电压变化幅度超过⼀定的门限值时, 就认为总线上⾄少有两个站同时在发送数据, 表明产⽣了碰撞. 所谓 “碰撞” 就是发⽣了冲突. 因此 “碰撞检测” 也称为 “冲突检测”.</p>
</details></section></p>
<p>以太⽹使⽤截断⼆进制指数退避 [truncated binary exponential backoff] 算法来确定碰撞后重传的时机. 截断⼆进制指数退避算法并不复杂. 这种算法让发⽣碰撞的站在停⽌发送数据后, 不是等待信道变为空闲后就⽴即再发送数据, ⽽是退避⼀个随机的时间 $r 2^\tau$. 其中</p>
<ul>
<li>$r \in \operatorname{random}([0, 1, \cdots, 2^k-1])$.</li>
<li>$k = \min(\str{重传次数}, 10)$.</li>
</ul>
<p>$\textbf{Remark.}$ 以太⽹规定了⼀个最短帧长 64 字节, 即 512 ⽐特.</p>
</details></section></p>
<p>数据链路层把网络层交下来的数据构成帧发送到链路上, 以及把接收到的帧中的数据取出并上交给网络层. 在互联网中, 网络层协议数据单元就是 IP 数据报 (或简称为数据报、分组或包).</p>
<p>数据链路层协议有许多种, 但有三个基本问题则是共同的. 这三个基本问题是:</p>
<ol>
<li><p>封装成帧. <br />
就是在一段数据的前后分别添加首部 <em>帧头</em> 和尾部 <em>帧尾</em>, 这样就构成了一个帧.</p>
</li>
<li><p>透明传输. <br />
插入转义字符 <code>ESC</code> (escape). 这种方法称为 <em>字节填充</em> (byte stuffing) 或 <em>字符填充</em> (character stuffing).</p>
</li>
<li><p>差错检测. 目前广泛使用 <span class="link local"><a href="/408/network/cyclic-redundancy-check.html" title="循环冗余检验 [408/network/cyclic-redundancy-check]">循环冗余检验 CRC</a></span>.</p>
</li>
</ol>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-cyclic-redundancy-check"><header><h1><span class="taxon"></span>循环冗余检验 <a class="slug" href="/408/network/cyclic-redundancy-check.html">[cyclic-redundancy-check]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/cyclic-redundancy-check.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\len{\operatorname{length}}$</p>
<p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\str#1{{\footnotesize #1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$</p>
<p>新帧 $M \cdot 2^n + R$ 的计算可通过 $\mathbf{F}_2[X]$ 上的带余除法 $(M, P) \to (Q, R)$ 完成. 这里 $n$ 是 $\deg P$, 即 $P$ 的位长度减一.</p>
<p>$$
\hint{源数据} ~ M \cdot 2^n \spaces= \hint{生成多项式} ~ P \cdot \hint{} ~ Q + \hint{校验码} ~ R
$$</p>
<p>$\textbf{Example.}$ $M = 10110011$, $P = 10011$, 按以下步骤求得 $R = 0100$.</p>
<p>$$
\begin{array}{ll}
& \hspace{0.9em} x^7 + x^5 + x^3 + x^2 \\
x^4 + x + 1 
& \sqrt{x^{11} + x^9 + x^8 + x^5 + x^4} \\
& \hspace{0.9em} x^{11} + x^8 + x^7 \\
& \hspace{0.6em} \text{------------------------------} \\
& \hspace{3em} x^9 + x^7 + x^5 + x^4 \\
& \hspace{3em} x^9 + x^6 + x^5 \\
& \hspace{3em} \text{-----------------------} \\
& \hspace{5.2em} x^7 + x^6 + x^4 \\
& \hspace{5.2em} x^7 + x^4 + x^3 \\
& \hspace{5.2em} \text{-----------------} \\
& \hspace{7.4em} x^6 + x^3 \\
& \hspace{7.4em} x^6 + x^3 + x^2 \\
& \hspace{7.4em} \text{-----------------} \\
& \hspace{9.6em} x^2
\end{array}
$$</p>
</details></section></p>
<p>$\textbf{Remark.}$ 在数据链路层若 <em>仅仅</em> 使用循环冗余检验 CRC 差错检测技术, 则只能做到对帧的 <em>无差错接受</em>, 即: “凡是接收端数据链路层接受的帧, 我们都能以非常接近于 1 的概率认为这些帧在传输过程中没有产生差错”. 接收端丢弃的帧虽然曾收到了, 但最终还是因为有差错被丢弃, 即没有被接受. 以上所述的可以 <em>近似地</em> 表述为 (通常都是这样认为): <em>“凡是接收端数据链路层接受的帧均无差错”</em>.</p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-network-layer"><header><h1><span class="taxon"></span>网络层 <a class="slug" href="/408/network/network-layer.html">[network-layer]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/network-layer.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
img {
  border-radius: 0.2em; 
  width: 400px;
}
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
</style>
<p>在计算机⽹络领域, ⽹络层应该向运输层提供怎样的服务 (即 “⾯向连接” 还是 “⽆连接”) 曾引起了长期的争论.
争论焦点的实质就是: 在计算机通信中, 可靠交付应当由谁来负责? 是⽹络还是端系统?</p>
<p>互联⽹采⽤的设计思路是这样的: <em>⽹络层要设计得尽量简单, 向其上层只提供简单灵活的、⽆连接的、 尽最⼤努⼒交付的数据报服务.</em>
这⾥的 “数据报”(datagram) 是互联⽹的设计者最初使⽤的名词, 其实数据报 (或 IP 数据报) 就是我们经常使⽤的 “分组”.
我们约定 IP 数据报和 IP 分组是同义词, 可以混⽤.</p>
<p>⽹络在发送分组时不需要先建⽴连接. 每⼀个分组 (也就是 IP 数据报) 独⽴发送, 与其前后的分组⽆关 (不进⾏编号). <em>⽹络层不提供服务质量的承诺.</em> 也就是说, 所传送的分组可能出错、 丢失、 重复和失序 (即不按序到达终点), 当然也不保证分组交付的时限. 由于 <em>传输⽹络不提供端到端的可靠传输服务</em>, 这就使⽹络中的路由器⽐较简单, 且价格低廉(与电信⽹的交换机相⽐较). 如果主机 (即端系统) 进程之间需要进⾏可靠的通信, 那么就由主机中的 <span class="link local"><a href="/408/network/transport-layer.html" title="运输层 [408/network/transport-layer]">运输层</a></span> 负责 (包括差错处理、 流量控制等). 分组交换进一步分为面向连接的 <span class="link local"><a href="/408/network/virtual-circuit.html" title="虚电路 [408/network/virtual-circuit]">虚电路</a></span> 和无连接的 <span class="link local"><a href="/408/network/datagram.html" title="数据报 [408/network/datagram]">数据报</a></span>.</p>
<ul>
<li><section class="block hide-metadata" data-taxon=""><details ><summary id="408-network-virtual-circuit"><header><h1><span class="taxon"></span>虚电路 <a class="slug" href="/408/network/virtual-circuit.html">[virtual-circuit]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/virtual-circuit.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li><p>步骤:</p>
<ol>
<li>在源主机和目的主机之间建立一条虚连接, 用户发送的数据 (以分组为单位) 将通过该路径按顺序传送到达目的主机. 当通信完成之后用户发出释放虚电路主机请求, 由网络清除该虚连接.</li>
<li>选择未用过的虚电路号分配给虚电路, 区别于其他虚电路, 虚电路网络中的每个结点上都维持一张虚电路表, 包括在接收链路和发送链路上的虚电路号、前一结点和下一结点的标识. 数据的传输是双向进行的.</li>
</ol>
</li>
<li><p>建立步骤:</p>
<ol>
<li>虚电路建立. 主机 A 发出一个特殊的 “呼叫请求” 分组, 该分组通过中间结点送往主机B, 若主机 B 同意连接, 则发送“呼叫应答“分组予以确认.</li>
<li>数据传输. 电路建立后, 主机 A 就可向主机 B 发送数据分组. 主机 B 也可在该虚电路上向主机 A 发送数据.</li>
<li>虚电路释放. 传送结束后主机 A 通过发送“释放请求“分组来拆除虚电路, 逐段断开整个连接.</li>
</ol>
</li>
<li><p>特点:</p>
<ol>
<li>虚电路通信链路的建立和拆除需要时间开销, 但对长时间、频繁的数据交换效率较高.</li>
<li>虚电路的路由选择体现在连接建立阶段, 连接建立确定传输路径.</li>
<li>虚电路提供可靠通信功能, 能保证每个分组正确且有序到达. 对两个数据端点流量控制, 当接收方来不及接收数据时, 可以通知发送方暂缓发送.</li>
<li>虚电路有网络中的某个结点或某条链路出现故障而彻底失效时, 所有经过该结点或该链路的虚电路将遭到破坏.</li>
<li>分组首部不包含目的地址, 包含虚电路标识符. 虚电路电路不是专用的,每个结点到其他结点之间的链路可能同时有若干虚电路通过, 也可能同时与多个结点之间建立虚电路.</li>
</ol>
</li>
</ul>
</details></section></li>
<li><section class="block hide-metadata" data-taxon=""><details ><summary id="408-network-datagram"><header><h1><span class="taxon"></span>数据报 <a class="slug" href="/408/network/datagram.html">[datagram]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/datagram.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li><p>步骤:</p>
<ol>
<li>把报文拆成若干带有序号的数据单元, 在网络层加上地址等控制信息后形成数据报分组 (网络层的 PDU).</li>
<li>中间结点存储分组, 找到最佳的路由后, 尽快转发每个分组. 不同的分组可以走不同的路径, 按不同的顺序到达目的结点.</li>
</ol>
</li>
<li><p>特点:</p>
<ol>
<li>发送分组前不需要建立连接. 发送方可随时发送分组, 结点可随时接收分组.</li>
<li>网络尽最大努力交付, 传输不保证可靠性, 可能丢失; 每个分组独立选择路由, 转发路径可能不同, 分组不一定按序到达目的结点.</li>
<li>发送的分组中要包括发送端和接收端的完整地址, 独立传输.</li>
<li>分组在交换结点存储转发时, 需要排队等候处理. 通过交换结点的通信较大或网络发生拥塞时, 时延增加, 交换结点可根据情况丢弃部分分组.</li>
<li>网络具有冗余路径, 当某个交换结点或一条链路出现故障时, 可相应地更新转发表, 寻找另一条路径转发分组, 对故障适应能力强.</li>
<li>存储转发延时一般较小, 提高网络吞吐量.</li>
<li>收发双方不独占某条链路, 资源利用率较高</li>
</ol>
</li>
</ul>
</details></section></li>
</ul>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-virtual-circuit-vs-datagram"><header><h1><span class="taxon"></span>虚电路和数据报服务的对比 <a class="slug" href="/408/network/virtual-circuit-vs-datagram.html">[virtual-circuit-vs-datagram]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/virtual-circuit-vs-datagram.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><table><thead><tr><th>对⽐方面</th><th>虚电路服务</th><th>数据报服务</th></tr></thead><tbody>
<tr><td>思路</td><td>可靠通信应当由⽹络来保证</td><td>可靠通信应当由⽤户主机来保证</td></tr>
<tr><td>连接的建⽴</td><td>必须有</td><td>不需要</td></tr>
<tr><td>终点地址</td><td>仅在连接建⽴阶段使⽤, 每个分组使⽤短的虚电路号</td><td>每个分组都有终点的完整地址, 即 IP 地址</td></tr>
<tr><td>分组的转发</td><td>属于同⼀条虚电路的分组均按照同⼀路由进⾏转发</td><td>每个分组独⽴查找转发表进⾏转发</td></tr>
<tr><td>当节点出故障时</td><td>所有通过出故障的节点的虚电路均不能⼯作</td><td>出故障的节点可能会丢失分组, ⼀些路由可能会发⽣变化</td></tr>
<tr><td>分组的顺序</td><td>总是按发送顺序到达终点</td><td>到达终点的顺序不⼀定按发送的顺序</td></tr>
<tr><td>端到端的差错处理和流量控制</td><td>可以由⽹络负责, 也可以由⽤户主机负责</td><td>由⽤户主机负责</td></tr>
</tbody></table>
</details></section></p>
<br>
<p>互联网协议套件 [Internet Protocol Suite, IPS] 是一种网络通信模型, 以及用于网络传输的协议集合, 为网际网络的基础通信架构. 被应用于各种网络通信中. 它常通称为 TCP/IP 协议族, 简称TCP/IP 因为该协议家族的两个核心协议: <span class="link local"><a href="/408/network/tcp.html" title="传输控制协议 TCP [408/network/tcp]">传输控制协议 TCP</a></span> 和 <span class="link local"><a href="/408/network/ip.html" title="网际协议 IP [408/network/ip]">网际协议 IP</a></span> 为该家族中最早通过的标准.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-ip"><header><h1><span class="taxon"></span>网际协议 IP <a class="slug" href="/408/network/ip.html">[ip]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/ip.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
img {
  border-radius: 0.2em; 
  width: 400px;
}
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
</style>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-dotted-decimal-notation"><header><h1><span class="taxon"></span>IP 地址的表示 <a class="slug" href="/408/network/dotted-decimal-notation.html">[dotted-decimal-notation]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/dotted-decimal-notation.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>对主机或路由器来说, IP 地址都是 32 位的⼆进制代码. 为了提⾼可读性, 书写时常常把 32 位的 IP 地址中的每隔 8 位插⼊⼀个空格. 也是为了便于书写记忆, 常⽤其等效的⼗进制数字表⽰, 并且在每段数字之间加上⼀个⼩数点.</p>
<p>$\textbf{Example.}$</p>
<p>$$
\underbrace{10000000}_{128} ~~ \underbrace{00001011}_{11} ~~ \underbrace{00000011}_{3} ~~ \underbrace{00011111}_{31} \\
\darr \\
128.11.3.31
$$</p>
</details></section></p>
<p>与协议 IP 配套使⽤的还有三个协议:</p>
<ul>
<li><span class="link local"><a href="/408/network/arp.html" title="地址解析协议 ARP [408/network/arp]">地址解析协议 ARP</a></span> [Address Resolution Protocol].</li>
<li>⽹际控制报⽂协议 ICMP [Internet Control Message Protocol].</li>
<li>⽹际组管理协议 IGMP [Internet Group Management Protocol].</li>
</ul>
<p>给每个主机 (或路由器) 的接口分配⼀个 IP 地址, 其含义就是这个 IP 地址不但标志了这个主机 (或路由器), ⽽且还标志了此接口所连接的⽹络. 因此, 32 位的 IP 地址采⽤两级结构, 由两个字段组成. 第⼀个字段是 <em>⽹络号</em>, 它标志主机 (或路由器) 所连接到的⽹络.⼀个⽹络号在整个互联⽹范围内必须是唯⼀的. 第⼆个字段是 <em>主机号</em>, 它标志该主机 (对路由器来说, 就是标志该路由器). ⼀个主机号在所连接的⽹络 (即前⾯的⽹络号所指明的⽹络) 中必须是唯⼀的. 由此可见, ⼀个 IP 地址 <em>在整个互联⽹范围内是唯⼀的</em>. 因此, IP 地址可以记为</p>
<pre><code>IP := { &lt;⽹络号&gt;, &lt;主机号&gt; }
</code></pre>
<p>IP 地址中的前 $n$ 位是主机所连接的⽹络号, ⽽ IP 地址中后⾯的 $32-n$ 位是主机号.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-ip-category"><header><h1><span class="taxon"></span>分类 IP 地址 <a class="slug" href="/408/network/ip-category.html">[ip-category]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/ip-category.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>在互联⽹发展早期采⽤的是分类的 IP 地址, 也就是要求 $n$ 是固定的⼏个数 ($8, 16, 24$) 之⼀. 由于近年来已经⼴泛使⽤⽆分类 IP 地址进⾏路由选择, A 类、 B 类和 C 类这种分类地址已成为历史. 把 IP 地址划分为 A 类、 B 类、 C 类三个类别, 当初是这样考虑的: 各种⽹络的差异很⼤, 有的⽹络拥有很多主机,⽽有的⽹络上的主机则很少. 把 IP 地址划分为 A 类、 B 类和C 类是为了更好地满⾜不同⽤户的需求.</p>
<table><thead><tr><th>网络类别</th><th>IP 范围</th><th>网络地址位数</th><th>默认子网掩码</th></tr></thead><tbody>
<tr><td>A</td><td><code>1</code> ~ <code>126</code></td><td>8</td><td><code>255.0.0.0</code></td></tr>
<tr><td>B</td><td><code>128.1</code> ~ <code>191.255</code></td><td>16</td><td><code>255.255.0.0</code></td></tr>
<tr><td>C</td><td><code>192.0.1</code> ~ <code>223.255.255</code></td><td>24</td><td><code>255.255.255.0</code></td></tr>
</tbody></table>
</details></section></p>
<p>在 20 世纪 90 年代, 当发现 IP 地址在不久后将会枯竭时, ⼀种新的⽆分类编址⽅法 CIDR 就问世了. 这种⽅法虽然也⽆法解决 IP 地址枯竭的问题, 但可以推迟 IP 地址⽤尽的⽇子.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-cidr"><header><h1><span class="taxon"></span>⽆分类编址⽅法 CIDR <a class="slug" href="/408/network/cidr.html">[cidr]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/cidr.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>CIDR 把⽹络号改称为 “⽹络前缀” [network-prefix] 或简称为“前缀”, ⽤来指明⽹络, 剩下的后⾯部分仍然是主机号或称为后缀, ⽤来指明主机.</p>
<pre><code>IP := { &lt;⽹络前缀&gt;, &lt;主机号&gt; }
</code></pre>
<p>相比 分类的 IP 地址, 这⾥最⼤的区别就是⽹络前缀的位数 n 不是固定的数,⽽是可以在 0~32 之间选取任意的值.</p>
<p>CIDR 使⽤ “斜线记法” [slash notation], 或称 CIDR 记法, 即在 IP 地址后⾯加上斜线 <code>/</code>, 斜线后⾯是⽹络前缀所占的位数. 例如, CIDR 表⽰的⼀个 IP 地址 <code>128.14.35.7/20</code>, ⼆进制 IP 地址的前 20 位是⽹络前缀, 相当于原来的⽹络号, 剩下后⾯ 12 位是主机号.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-subnet-mask"><header><h1><span class="taxon"></span>子网掩码 <a class="slug" href="/408/network/subnet-mask.html">[subnet-mask]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/subnet-mask.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\str#1{{\footnotesize #1}}$
$\gdef\spaces#1{~ #1 ~}$</p>
<p>计算机为了能够从 IP 地址迅速算出⽹络地址, 引入了 32 位的地址掩码. 地址掩码常简称为掩码, 由⼀连串 <code>1</code> 和接着的⼀连串 <code>0</code> 组成,⽽ <code>1</code> 的个数就是⽹络前缀的长度. 地址掩码又称为⼦⽹掩码. 在 CIDR 记法中, 斜线后⾯的数字就是地址掩码中 <code>1</code> 的个数. 例如, <code>/20</code> 地址块的地址掩码是 20 个连续的 <code>1</code> 和接着的 12 个连续的 <code>0</code>:</p>
<pre><code>11111111 11111111 11110000 00000000
</code></pre>
<p>这个掩码⽤ CIDR 记法表⽰就是 <code>255.255.240.0/20</code>, <code>240</code> 来自 $255 - (2^4 - 1) = 240$.</p>
<ul>
<li>目的: 使路由器知道 IP 地址是否使用了子网划分, 并且能快速知道子网号.</li>
<li>优点: 只要把子网掩码和 IP 地址逐位进行与运算, 可以得出网络地址. <span class="link local"><a href="/408/network/cidr.html" title="⽆分类域间路由选择 CIDR [408/network/cidr]">主机号</a></span> 全变 0.</li>
</ul>
<p>$$
\str{网络地址} \spaces= \str{\text{IP 地址}} \spaces\& \str{子网掩码}
$$</p>
<p>$\textbf{Example.}$ IP 地址为 <code>89.189.72.35</code>, 子网掩码为 <code>255.255.0.0</code>, 则该 IP 地址中, 网络地址占前几位?</p>
<p>$$
\begin{array}{ll}
& 01011001 ~ 10111101 ~ 01001000 ~ 00100011 \\
\& & 11111111 ~ 11111111 ~ 00000000 ~ 00000000 \\
\hline \\
& 01011001 ~ 10111101 ~ \cdots
\end{array}
$$</p>
<p>故前 16 位.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-address-count"><header><h1><span class="taxon"></span>可用地址总数 <a class="slug" href="/408/network/address-count.html">[address-count]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/address-count.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\str#1{{\footnotesize #1}}$</p>
<p>一般出现在填空题的计算中. 使用如下公式即可</p>
<p>$$
(2^n-2)(2^{N-n}-2)
$$</p>
<p>$\textbf{Example.}$ 我们举一例, 对 <span class="link local"><a href="/408/network/ip-category.html" title="分类 IP 地址 [408/network/ip-category]">C 类网络</a></span> <code>202.78.135.192</code> 计算其可用地址总数.</p>
<ul>
<li>$202.78.135.192 \to N = 32 - 24 = 8$.</li>
<li>$255.255.255.192 \to n = 2$.</li>
</ul>
<p>故总数为 $(2^2-2)(2^6-2) = 2 \times 62 = 124$.</p>
</details></section></p>
</details></section></p>
<p>在局域⽹中, 由于 MAC 地址已固化在⽹卡上的 ROM 中, 因此常常将 MAC 地址称为硬件地址或物理地址. 从层次的⾓度看, MAC 地址是数据链路层使⽤的地址,⽽IP 地址是⽹络层和以上各层使⽤的地址, 是⼀种逻辑地址.</p>
<p>在发送数据时, 数据从⾼层下到低层, 然后才到通信链路上传输. 使⽤IP 地址的 IP 数据报⼀旦交给数据链路层, 就被封装成 MAC 帧. MAC 帧在传送时使⽤的源地址和⽬的地址都是 MAC 地址, 这两个 MAC 地址都写在 MAC 帧的⾸部中.连接在通信链路上的设备 (主机或路由器) 在收到 MAC 帧时, 根据 MAC 帧⾸部中的MAC 地址决定收下或丢弃. 只有在剥去 MAC 帧的⾸部和尾部后把 MAC 层的数据上交给⽹络层后,⽹络层才能在 IP 数据报的⾸部中找到源 IP 地址和⽬的 IP 地址. 简单来说, 32bit 的 IP 地址确定唯一的主机, 48bit 的 MAC 地址找到唯一的接口.</p>
<p>总之, IP 地址放在 IP 数据报的⾸部,⽽ MAC 地址则放在 MAC 帧的⾸部. 在⽹络层和⽹络层以上使⽤的是 IP 地址, ⽽数据链路层及以下使⽤的是 MAC 地址. 即 <em>IP 地址放在网络层的首部, 而硬件地址则放数据链路层的首部.</em> 当 IP 数据报插⼊到数据链路层的 MAC 帧以后, 整个的 IP 数据报就成为 MAC 帧的数据, 因⽽在数据链路层看不见数据报的 IP 地址.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-ip-datagram"><header><h1><span class="taxon"></span>IP 数据报的格式 <a class="slug" href="/408/network/ip-datagram.html">[ip-datagram]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/ip-datagram.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
img {
  border-radius: 0.2em; 
  width: 400px;
}
</style>
<p>一个 IP 数据报由首部和数据两部分组成:</p>
<ul>
<li>首部的前一部分是固定长度, 共 20 字节, 是所有 IP 数据报必须具有的.</li>
<li>在首部的固定部分的后面是一些可选字段, 其长度是可变的.</li>
</ul>
<div style="text-align: center;">
<p><img src="/assets/ipv4-header.png" title="" alt=""></p>
</div>
<ul>
<li>总长度. 占 16bit. 指首部和数据之和的长度, 单位为字节, 因此数据报的最大长度为 $2^{16}-1$ 65535 字节 (B).总 长度必须不超过 <span class="link local"><a href="/408/network/maximum-transmission-unit.html" title="最⼤传送单元 [408/network/maximum-transmission-unit]">最大传送单元 MTU</a></span>.</li>
<li>片偏移. 占 13bit. 指出较长的分组在分片后, 某片在原分组中的相对位置. 片偏移以 8 个字节 (8B) 为偏移单位.</li>
<li>标识. 占 16bit. 计数器, 每产生一个数据报就加 1, 当一个数据报的长度超过网络的 <span class="link local"><a href="/408/network/maximum-transmission-unit.html" title="最⼤传送单元 [408/network/maximum-transmission-unit]">MTU</a></span> 时, 必须分片, 每个数据报片都复制一次标识号, 以便重装成原来数据报. 属于同一个数据报各分片有相同的标识.</li>
<li>区分服务, 占 8bit. 用来获得更好的服务.在旧标准中叫做服务类型, 但实际上一直未被使用过.1998 年这个字段改名为区分服务. 只有在使用区分服务 [DiffServ] 时, 这个字段才起作用. 在一般的情况下都不使用这个字段.</li>
<li>标志. 占 3bit. 标志字段的最低位为 <code>MF</code> [More Fragment], <code>MF=1</code> 表示后面还有分片, <code>MF=0</code> 表示最后一个分片. 标志字段中间一位是 DF [Don’t Fragment], 只有当 <code>DF=0</code> 时才允许分片.</li>
<li>生存时间 TTL. 占 8bit. 路由器在转发分组前, 先把 TTL 减 1. <em>若 TTL 被减为 0, 则该分组必须丢弃</em>.</li>
<li>首部校验和. 占 16bit. 只校验分组的首部, 而不校验数据部分. 每经过一个路由器, 都重新计算.</li>
</ul>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-sharding-offset"><header><h1><span class="taxon"></span>分片与片偏移大小的计算 <a class="slug" href="/408/network/sharding-offset.html">[sharding-offset]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/sharding-offset.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
img {
  border-radius: 0.2em; 
  width: 400px;
}
</style>
<p>$\textbf{Example.}$ 一个数据报长度为 4000 字节, <em>固定首部长度 20</em>. 现在经过一个网络传送, 但 <em>此网络能够传送的最大数据长度为 1500 字节</em>. 试问应当划分为几个短些的数据报片? 各数据报片的数据字段长度、片偏移字段和 MF 标志应为何数值?</p>
<table><thead><tr><th></th><th>总长度</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody>
<tr><td>原始</td><td>4000</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>数据报片 1</td><td>1500</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>数据报片 2</td><td>1500</td><td>1</td><td>0</td><td>185</td></tr>
<tr><td>数据报片 3</td><td>1040</td><td>0</td><td>0</td><td>370</td></tr>
</tbody></table>
<p>其中数据报片 3 的 $1040$ 来自 $((4000 - 20) \mod (1500 - 20)) + 20$. 片偏移 $185$ 来自 $\frac{1500-20}{8}$.</p>
<p>$\textbf{Example.}$ 数据报长度为 4800 字节. 网络能够传送的最大数据长度为 1420 字节.</p>
<table><thead><tr><th></th><th>总长度</th><th>MF</th><th>DF</th><th>片偏移</th></tr></thead><tbody>
<tr><td>原始</td><td>4800</td><td>0</td><td>0</td><td>0</td></tr>
<tr><td>数据报片 1</td><td>1420</td><td>1</td><td>0</td><td>0</td></tr>
<tr><td>数据报片 2</td><td>1420</td><td>1</td><td>0</td><td>175</td></tr>
<tr><td>数据报片 3</td><td>1420</td><td>1</td><td>0</td><td>350</td></tr>
<tr><td>数据报片 4</td><td>600</td><td>0</td><td>0</td><td>525</td></tr>
</tbody></table>
<p>$(4800 - 20) \mod (1420 - 20) + 20 = 600$. $\frac{1420 - 20}{8} = 175$.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details ><summary id="408-network-ip-forward-group"><header><h1><span class="taxon"></span>IP 转发分组流程 <a class="slug" href="/408/network/ip-forward-group.html">[ip-forward-group]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/ip-forward-group.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ol>
<li>从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址 N.</li>
<li>若网络 N 与此路由器直接相连, 则把数据报直接交付给目的主机 D; 否则是间接交付, 执行步骤 3.</li>
<li>若路由表中有目的地址为 D 的特定主机路由, 则把数据报传送给路由表中所指明的下一跳路由器; 否则, 执行步骤 4.</li>
<li>若路由表中有到达网络 N 的路由, 则把数据报传送给路由表指明的下一跳路由器; 否则, 执行步骤 5.</li>
<li>若路由表中有一个默认路由, 则把数据报传送给路由表中所指明的默认路由器; 否则, 执行步骤 6.</li>
<li>报告转发分组出错 (ICMP).</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details ><summary id="408-network-ip-convert-mac"><header><h1><span class="taxon"></span>IP 转换 MAC <a class="slug" href="/408/network/ip-convert-mac.html">[ip-convert-mac]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/ip-convert-mac.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
img {
  border-radius: 0.2em; 
  width: 400px;
}
</style>
<ol>
<li>得到下一跳路由器的 IP 地址后并不是直接将该地址填入待发送的数据报, <em>而是将该 IP 地址转换成 MAC 地址 (通过 ARP)</em>, 将其放到 MAC 帧首部中, 然后根据这个 MAC 地址找到下一跳路由器.</li>
<li>在不同网络中传送时, MAC 帧中的源地址和目的地址要发生变化, 但是网桥转发帧时, 不改变帧的源地址.</li>
<li><em>路由表并没有给分组指明到某个网络的完整路径</em>. 路由表指出, 到某个网络应当先到某个路由器 (下一跳), 在到达以后, 继续查找路由表, 知道再下一步到哪个路由器.</li>
</ol>
</details></section></p>
</details></section></p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-transport-layer"><header><h1><span class="taxon"></span>运输层 <a class="slug" href="/408/network/transport-layer.html">[transport-layer]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/transport-layer.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(201, 152, 244);
  font-style: normal;
}
</style>
<p>从通信和信息处理的⾓度看, <em>运输层向它上⾯的 <span class="link local"><a href="/408/network/application-layer.html" title="应用层 [408/network/application-layer]">应⽤层</a></span> 提供通信服务</em>, 它属于⾯向通信部分的最⾼层, 同时也是⽤户功能中的最低层. 当⽹络边缘部分的两台主机使⽤⽹络核⼼部分的功能进⾏端到端的通信时, 都要使⽤协议栈中的运输层,⽽⽹络核⼼部分中的路由器在 <em>转发分组时只⽤到下三层的功能</em>.</p>
<p>运输层的重要功能:</p>
<ul>
<li>复⽤ [multiplexing], 是指在发送⽅不同的应⽤进程都可以使 ⽤同⼀个运输层协议传送数据 (当然需要加上适当的⾸部).</li>
<li>分⽤ [demultiplexing]. 是指接收⽅的运输层在剥去报⽂的⾸部后能够把这些数据正确交付⽬的应⽤进程.</li>
</ul>
<p>从这⾥可以看出 <span class="link local"><a href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">⽹络层</a></span> 和运输层有明显的区别. <em><span class="link local"><a href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">⽹络层</a></span> 为主机之间的通信提供服务, ⽽运输层则在⽹络层的基础上, 为应⽤进程之间的通信提供服务.</em> 然⽽正如后⾯还要讨论的, 运输层还具有 <span class="link local"><a href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">⽹络层</a></span> ⽆法代替的许多其他重要功能.</p>
<p>运输层还要对收到的报⽂进⾏差错检测. 在 <span class="link local"><a href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">⽹络层</a></span>, IP 数据报⾸部中的检验和字段只检验⾸部是否出现差错⽽不检查数据部分.</p>
<p>根据应⽤程序的不同需求, 运输层需要有两种不同的运输协议, 即⾯向连接的 <span class="link local"><a href="/408/network/tcp.html" title="传输控制协议 TCP [408/network/tcp]">TCP</a></span> 和⽆连接的 <span class="link local"><a href="/408/network/udp.html" title="⽤户数据报协议 UDP [408/network/udp]">UDP</a></span>.</p>
<ul>
<li><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-udp"><header><h1><span class="taxon"></span>⽤户数据报协议 UDP <a class="slug" href="/408/network/udp.html">[udp]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/udp.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>⽤户数据报协议 UDP 只在 IP 的 <span class="link local"><a href="/408/network/ip-datagram.html" title="IP 数据报的格式 [408/network/ip-datagram]">数据报</a></span> 服务之上增加了很少⼀点的功能, 这就是 <span class="link local"><a href="/408/network/transport-layer.html" title="运输层 [408/network/transport-layer]">复⽤和分⽤</a></span> 的功能以及差错检测的功能. 当运输层采⽤⽆连接的 UDP 协议时, 这种逻辑通信信道仍然是⼀条不可靠信道.</p>
<ol>
<li>UDP 是无连接的, 发送数据之前不需要建立连接, 因此减少了开销和发送数据之前的时延.</li>
<li>UDP 使用尽最大努力交付, 即不保证可靠交付, 因此主机不需要维持复杂的连接状态表.</li>
<li>UDP 是面向报文的. UDP 对应用层交下来的报文, 既不合并, 也不拆分, 而是保留这些报文的边界. UDP 一次交付一个完整的报文.</li>
<li>UDP 没有拥塞控制, 因此网络出现的拥塞不会使源主机的发送速率降低. 这对某些实时应用是很重要的. 很适合多媒体通信的要求.</li>
<li>UDP 支持一对一、 一对多、 多对一和多对多的交互通信.</li>
<li>UDP 的首部开销小, 只有 8 个字节, 比 <span class="link local"><a href="/408/network/tcp.html" title="传输控制协议 TCP [408/network/tcp]">TCP</a></span> 的 20 个字节的首部要短.</li>
</ol>
</details></section></li>
<li><section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-tcp"><header><h1><span class="taxon"></span>传输控制协议 TCP <a class="slug" href="/408/network/tcp.html">[tcp]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/tcp.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>当运输层采⽤⾯向连接的 TCP 协议时, 尽管下⾯的⽹络是不可靠的 (只提供尽最⼤努⼒服务), 但这种逻辑通信信道就相当于⼀条全双⼯的可靠信道. 以下列出 TCP 最主要的特点:</p>
<ol>
<li>TCP 是⾯向连接的运输层协议.</li>
<li>每⼀条 TCP 连接只能有两个端点 (endpoint), 每⼀条 TCP 连接只能是点对点的 (⼀对⼀).</li>
<li>TCP 提供可靠交付的服务. 通过 TCP 连接传送的数据,⽆差错、 不丢失、 不重复,并且按序到达.</li>
<li>TCP 提供全双⼯通信. TCP 允许通信双⽅的应⽤进程在任何时候都能发送数据. TCP 连接的两端都设有发送缓存和接收缓存, ⽤来临时存放双向通信的数据. 在发送时,应⽤程序在把数据传送给 TCP 的缓存后, 就可以做⾃⼰的事, ⽽TCP 在合适的时候把数据发送出去. 在接收时, TCP 把收到的数据放⼊缓存, 上层的应⽤进程在合适的时候读取缓存中的数据.</li>
<li>⾯向字节流. TCP 中的 “流” (stream) 指的是流⼊到进程或从进程流出的字节序列. “⾯向字节流” 的含义是: 虽然应⽤程序和 TCP 的交互是⼀次⼀个数据块 (⼤⼩不等), 但TCP 把应⽤程序交下来的数据仅仅看成是⼀连串的⽆结构的字节流. TCP 并不知道所传送的字节流的含义.</li>
</ol>
<p>套接字 <code>socket = (IP 地址: 端口号)</code>. 每一条 TCP 连接唯⼀地被通信两端的两个端点, 即套接字对 socket pair 所确定.</p>
<pre><code>TCP 连接 := { socket1, socket2 } 
         = { (IP1, port1), (IP2, port2) } 
</code></pre>
</details></section></li>
</ul>
<!-- 
### 信道利⽤率 $U$

$$
U = \frac{T_D}{T_D + \text{RTT} + T_A}
$$ 
-->
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-network-application-layer"><header><h1><span class="taxon"></span>应用层 <a class="slug" href="/408/network/application-layer.html">[application-layer]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/network/application-layer.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary></details></section></p>
</details></section><footer><section class="block"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="" style="margin-bottom: 0.4em;"><header><h1><span class="taxon"></span>索引 <a class="slug" href="/index.html">[index]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/index.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></section></details></section></footer></article>

<nav id="toc"><div class="block"><h1>Table of Contents</h1><ul class="block"><li class=""><a class="bullet" href="/408/network/overview.html" title="概述 [408/network/overview]">■</a><span class="link local" onclick="window.location.href='#408-network-overview'"><span class="taxon"></span>概述</span><ul class="block"><li class=""><a class="bullet" href="/408/network/performance.html" title="计算机网络的性能 [408/network/performance]">■</a><span class="link local" onclick="window.location.href='#408-network-performance'"><span class="taxon"></span>计算机网络的性能</span><ul class="block"><li class=""><a class="bullet" href="/408/network/delay.html" title="时延 [408/network/delay]">■</a><span class="link local" onclick="window.location.href='#408-network-delay'"><span class="taxon"></span>时延</span></li></ul></li><li class=""><a class="bullet" href="/408/network/protocol.html" title="协议与划分层次 [408/network/protocol]">■</a><span class="link local" onclick="window.location.href='#408-network-protocol'"><span class="taxon"></span>协议与划分层次</span><ul class="block"><li class=""><a class="bullet" href="/408/network/layered-network-model.html" title="三种体系结构 [408/network/layered-network-model]">■</a><span class="link local" onclick="window.location.href='#408-network-layered-network-model'"><span class="taxon"></span>三种体系结构</span></li></ul></li></ul></li><li class=""><a class="bullet" href="/408/network/physical-layer.html" title="物理层 [408/network/physical-layer]">■</a><span class="link local" onclick="window.location.href='#408-network-physical-layer'"><span class="taxon"></span>物理层</span><ul class="block"><li class=""><a class="bullet" href="/408/network/physical-layer-0001.html" title="常用术语 [408/network/physical-layer-0001]">■</a><span class="link local" onclick="window.location.href='#408-network-physical-layer-0001'"><span class="taxon"></span>常用术语</span></li><li class=""><a class="bullet" href="/408/network/physical-layer-0002.html" title="有关信道的几个基本概念 [408/network/physical-layer-0002]">■</a><span class="link local" onclick="window.location.href='#408-network-physical-layer-0002'"><span class="taxon"></span>有关信道的几个基本概念</span></li><li class=""><a class="bullet" href="/408/network/modulation.html" title="调制 [408/network/modulation]">■</a><span class="link local" onclick="window.location.href='#408-network-modulation'"><span class="taxon"></span>调制</span></li><li class=""><a class="bullet" href="/408/network/encoding-method.html" title="数字信号编码方法 [408/network/encoding-method]">■</a><span class="link local" onclick="window.location.href='#408-network-encoding-method'"><span class="taxon"></span>数字信号编码方法</span></li><li class=""><a class="bullet" href="/408/network/maximum-capacity.html" title="信道的极限容量 [408/network/maximum-capacity]">■</a><span class="link local" onclick="window.location.href='#408-network-maximum-capacity'"><span class="taxon"></span>信道的极限容量</span></li><li class=""><a class="bullet" href="/408/network/transmission.html" title="信号传输方式 [408/network/transmission]">■</a><span class="link local" onclick="window.location.href='#408-network-transmission'"><span class="taxon"></span>信号传输方式</span></li><li class=""><a class="bullet" href="/408/network/multiplexing.html" title="信道复用技术 [408/network/multiplexing]">■</a><span class="link local" onclick="window.location.href='#408-network-multiplexing'"><span class="taxon"></span>信道复用技术</span></li></ul></li><li class=""><a class="bullet" href="/408/network/data-link-layer.html" title="数据链路层 [408/network/data-link-layer]">■</a><span class="link local" onclick="window.location.href='#408-network-data-link-layer'"><span class="taxon"></span>数据链路层</span><ul class="block"><li class=""><a class="bullet" href="/408/network/point-to-point.html" title="点对点 [408/network/point-to-point]">■</a><span class="link local" onclick="window.location.href='#408-network-point-to-point'"><span class="taxon"> 1. </span>点对点</span><ul class="block"><li class=""><a class="bullet" href="/408/network/point-to-point-1.html" title="PPP 协议的组成 [408/network/point-to-point-1]">■</a><span class="link local" onclick="window.location.href='#408-network-point-to-point-1'"><span class="taxon"></span>PPP 协议的组成</span></li></ul></li><li class=""><a class="bullet" href="/408/network/broadcast.html" title="广播 [408/network/broadcast]">■</a><span class="link local" onclick="window.location.href='#408-network-broadcast'"><span class="taxon"> 2. </span>广播</span><ul class="block"><li class=""><a class="bullet" href="/408/network/csma-cd.html" title="CSMA / CD [408/network/csma-cd]">■</a><span class="link local" onclick="window.location.href='#408-network-csma-cd'"><span class="taxon"></span>载波监听多点接⼊ / 碰撞检测</span></li></ul></li><li class=""><a class="bullet" href="/408/network/cyclic-redundancy-check.html" title="循环冗余检验 [408/network/cyclic-redundancy-check]">■</a><span class="link local" onclick="window.location.href='#408-network-cyclic-redundancy-check'"><span class="taxon"></span>循环冗余检验</span></li></ul></li><li class=""><a class="bullet" href="/408/network/network-layer.html" title="网络层 [408/network/network-layer]">■</a><span class="link local" onclick="window.location.href='#408-network-network-layer'"><span class="taxon"></span>网络层</span><ul class="block"><li class="item-summary"><a class="bullet" href="/408/network/virtual-circuit.html" title="虚电路 [408/network/virtual-circuit]">■</a><span class="link local" onclick="window.location.href='#408-network-virtual-circuit'"><span class="taxon"></span>虚电路</span></li><li class="item-summary"><a class="bullet" href="/408/network/datagram.html" title="数据报 [408/network/datagram]">■</a><span class="link local" onclick="window.location.href='#408-network-datagram'"><span class="taxon"></span>数据报</span></li><li class=""><a class="bullet" href="/408/network/virtual-circuit-vs-datagram.html" title="虚电路和数据报服务的对比 [408/network/virtual-circuit-vs-datagram]">■</a><span class="link local" onclick="window.location.href='#408-network-virtual-circuit-vs-datagram'"><span class="taxon"></span>虚电路和数据报服务的对比</span></li><li class=""><a class="bullet" href="/408/network/ip.html" title="网际协议 IP [408/network/ip]">■</a><span class="link local" onclick="window.location.href='#408-network-ip'"><span class="taxon"></span>网际协议 IP</span><ul class="block"><li class=""><a class="bullet" href="/408/network/dotted-decimal-notation.html" title="点分⼗进制记法 [408/network/dotted-decimal-notation]">■</a><span class="link local" onclick="window.location.href='#408-network-dotted-decimal-notation'"><span class="taxon"></span>IP 地址的表示</span></li><li class=""><a class="bullet" href="/408/network/ip-category.html" title="分类 IP 地址 [408/network/ip-category]">■</a><span class="link local" onclick="window.location.href='#408-network-ip-category'"><span class="taxon"></span>分类 IP 地址</span></li><li class=""><a class="bullet" href="/408/network/cidr.html" title="⽆分类域间路由选择 CIDR [408/network/cidr]">■</a><span class="link local" onclick="window.location.href='#408-network-cidr'"><span class="taxon"></span>⽆分类编址⽅法 CIDR</span><ul class="block"><li class=""><a class="bullet" href="/408/network/subnet-mask.html" title="子网掩码 [408/network/subnet-mask]">■</a><span class="link local" onclick="window.location.href='#408-network-subnet-mask'"><span class="taxon"></span>子网掩码</span></li><li class=""><a class="bullet" href="/408/network/address-count.html" title="可用地址总数 [408/network/address-count]">■</a><span class="link local" onclick="window.location.href='#408-network-address-count'"><span class="taxon"></span>可用地址总数</span></li></ul></li><li class=""><a class="bullet" href="/408/network/ip-datagram.html" title="IP 数据报的格式 [408/network/ip-datagram]">■</a><span class="link local" onclick="window.location.href='#408-network-ip-datagram'"><span class="taxon"></span>IP 数据报的格式</span><ul class="block"><li class=""><a class="bullet" href="/408/network/sharding-offset.html" title="分片与片偏移大小的计算 [408/network/sharding-offset]">■</a><span class="link local" onclick="window.location.href='#408-network-sharding-offset'"><span class="taxon"></span>分片与片偏移大小的计算</span></li><li class="item-summary"><a class="bullet" href="/408/network/ip-forward-group.html" title="IP 转发分组流程 [408/network/ip-forward-group]">■</a><span class="link local" onclick="window.location.href='#408-network-ip-forward-group'"><span class="taxon"></span>IP 转发分组流程</span></li><li class="item-summary"><a class="bullet" href="/408/network/ip-convert-mac.html" title="IP 转换 MAC [408/network/ip-convert-mac]">■</a><span class="link local" onclick="window.location.href='#408-network-ip-convert-mac'"><span class="taxon"></span>IP 转换 MAC</span></li></ul></li></ul></li></ul></li><li class=""><a class="bullet" href="/408/network/transport-layer.html" title="运输层 [408/network/transport-layer]">■</a><span class="link local" onclick="window.location.href='#408-network-transport-layer'"><span class="taxon"></span>运输层</span><ul class="block"><li class=""><a class="bullet" href="/408/network/udp.html" title="⽤户数据报协议 UDP [408/network/udp]">■</a><span class="link local" onclick="window.location.href='#408-network-udp'"><span class="taxon"></span>⽤户数据报协议 UDP</span></li><li class=""><a class="bullet" href="/408/network/tcp.html" title="传输控制协议 TCP [408/network/tcp]">■</a><span class="link local" onclick="window.location.href='#408-network-tcp'"><span class="taxon"></span>传输控制协议 TCP</span></li></ul></li><li class=""><a class="bullet" href="/408/network/application-layer.html" title="应用层 [408/network/application-layer]">■</a><span class="link local" onclick="window.location.href='#408-network-application-layer'"><span class="taxon"></span>应用层</span></li></ul></div></nav></div></body></html>