<!DOCTYPE html>
<html lang="en-US"><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width"><title>计算机操作系统</title><link rel="stylesheet" href="/main.css">
<link rel="stylesheet" href="/typst.css"><style>
  .katex .mfrac .frac-line {
    font-size: 1.25em;
  }

  li p {
    margin: 0;
  }

  a.link.local,
  .link.local a {
    box-shadow: none;
    text-decoration-line: underline;
    text-decoration-style: dotted;
    color: rgb(16, 180, 158);
  }

  table {
    border-collapse: collapse;
  }

  table th {
    text-align: left;
  }

  table th,
  table td {
    padding: 0.4em;
    border: 1px solid #ccc;
  }

  blockquote {
    margin: 0.5em;
    padding: 0.5em;
    outline: 1px solid #ccc;
    border-radius: 0.2em;
    font-style: normal;
  }

  blockquote p {
    margin: 0;
  }

  hint {
    color: gray;
  }

  em {
    color: rgb(249, 117, 131);
    font-style: normal;
  }
</style><link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&amp;family=Source+Sans+3:ital,wght@0,200..900;1,200..900&amp;family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&amp;display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Inria+Sans:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

<style>
body {
  font-family: "Inria Sans", "Source Sans", sans-serif;
}

pre,
code {
  font-family: "Source Code Pro", monospace;
}

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Inria Sans", sans-serif;
}

nav {
  font-family: "Inria Sans", sans-serif;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.css"
  integrity="sha384-zh0CIslj+VczCZtlzBcjt5ppRcsAmDnRem7ESsYwWwg3m/OaJ2l4x7YBZl9Kxxib" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/katex.min.js"
  integrity="sha384-Rma6DA2IPUwhNxmrB/7S3Tno0YY7sFu9WSYMCuulLhIqYSGZ2gKCJWIqhBWqMQfh" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/auto-render.min.js"
  integrity="sha384-hCXGrW6PitJEwbkoStFjeJxv+fSOOQKOPbJxSfM6G5sWZjAyWhXiTIIAmQqnlLlh" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.21/dist/contrib/copy-tex.min.js"
  integrity="sha384-HORx6nWi8j5/mYA+y57/9/CZc5z8HnEw4WUZWy5yOn9ToKBv1l58vJaufFAn9Zzi" crossorigin="anonymous"></script>

<script>
  document.addEventListener("DOMContentLoaded", function () {
    renderMathInElement(document.body, {
      delimiters: [
        { left: '$$', right: '$$', display: true },
        { left: '$', right: '$', display: false },
        { left: '\\(', right: '\\)', display: false },
        { left: '\\[', right: '\\]', display: true }
      ],
      strict: false,
      throwOnError: false,
      minRuleThickness: 0.05,
    });
  });
</script></head><body><header class="header"><nav class="nav"><div class="logo"><span onclick="window.location.href='/index.html'" title="索引">« 索引</span></div></nav></header><div id="grid-wrapper"><article><section class="block" data-taxon=""><details open><summary id="408-operating-system-index"><header><h1><span class="taxon"></span>计算机操作系统 <a class="slug" href="/408/operating-system/index.html">[operating-system]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/index.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-引论"><header><h1><span class="taxon"></span>引论 <a class="slug" href="/408/operating-system/引论.html">[引论]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/引论.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary></details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-进程"><header><h1><span class="taxon"></span>进程 <a class="slug" href="/408/operating-system/进程.html">[进程]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/进程.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>并发执行的问题引出了进程的概念. 进程 [Process] 是一个具有一定独立功能的程序关于某个数据集合的一次运行活动, 是系统进行 <em>资源分配和调度</em> 的一个独立单位.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-进程控制块"><header><h1><span class="taxon"></span>进程控制块 PCB <a class="slug" href="/408/operating-system/进程控制块.html">[进程控制块]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/进程控制块.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>系统为了 <em>管理</em> 进程而设置的一个 <em>数据结构</em>.</li>
<li>记录操作系统所需要的、用于描述进程的 <em>当前信息</em> 以及控制进程运行的 <em>全部信息</em>.</li>
<li>操作系统通过 <em>PCB</em> 感知进程的存在.</li>
<li>PCB 是进程存在的 <em>唯一标志</em>.</li>
<li>PCB 和进程是 <em>一一对应</em>.</li>
</ul>
<h4>PCB 的构成</h4>
<ul>
<li>标识符. 唯一地标识一个进程.<ul>
<li>内部标识符.</li>
<li>外部标识符.</li>
</ul>
</li>
<li>调度信息. 进程状态转换需要的信息.</li>
<li>处理机. 处理机中断或调用, 保护或恢复现场信息.</li>
<li>控制信息. 控制进程执行的节奏.</li>
</ul>
<h4>PCB 的组织方式</h4>
<ul>
<li>线性<ul>
<li>将所有 PCB 不分状态组织在一个连续表</li>
<li>优点: 简单、且不需要额外开销</li>
<li>缺点: 需扫描整个 PCB 表才能找到需要的 PCB</li>
<li>适应进程数目不多的系统</li>
</ul>
</li>
<li>链接<ul>
<li>将状态相同的 PCB 链接起来</li>
<li>等待队列可以有多个</li>
<li>就绪队列排队和调度算法有关</li>
</ul>
</li>
<li>索引<ul>
<li>在链接方式的指针和 PCB 间加入索引表, 即二级索引</li>
</ul>
</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-七态模型及调度"><header><h1><span class="taxon"></span>七态模型及调度 <a class="slug" href="/408/operating-system/七态模型及调度.html">[七态模型及调度]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/七态模型及调度.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p style="text-align: center;"><img class="theme" src="../../assets/full-seven-state-dispatch.svg" style="border-radius: 0.2em; width: 800px;"></p>
<p>由于多个进程在并发执⾏时共享系统资源, 致使它们在运⾏过程中呈现间断性的运⾏规律, 所以进程在其⽣命周期内可能具有多种状态.⼀般⽽⾔, 每⼀个进程⾄少应处于以下三种基本状态之⼀:</p>
<ul>
<li><p>就绪 [Ready] 状态. 这是指进程已处于准备好运⾏的状态, 即进程已分配到除 CPU以外的所有必要资源后, 只要再获得 CPU, 便可⽴即执⾏. 如果系统中有许多处于就绪状态的进程, 通常将它们按⼀定的策略 (如优先级策略) 排成⼀个队列, 称该队列为就绪队列.</p>
</li>
<li><p>执⾏ [Running] 状态. 这是指进程已获得 CPU, 其程序正在执⾏的状态. 对任何⼀个时刻⽽⾔, 在单处理机系统中, 只有⼀个进程处于执⾏状态,⽽在多处理机系统中, 则有多个进程处于执⾏状态.</p>
</li>
<li><p>阻塞 [Block] 状态. 这是指正在执⾏的进程由于发⽣某事件 (如 <code>I/O</code> 请求、 申请缓冲区失败等) 暂时⽆法继续执⾏时的状态, 亦即进程的执⾏受到阻塞. 此时引起进程调度, OS 把处理机分配给另⼀个就绪进程,⽽让受阻进程处于暂停状态,⼀般将这种暂停状态称为阻塞状态, 有时也称为等待状态或封锁状态. 通常系统将处于阻塞状态的进程也排成⼀队列, 称该队列为阻塞队列. 实际上, 在较⼤的系统中, 为了减少队列操作的开销, 提⾼系统效率, 根据阻塞原因的不同, 会设置多个阻塞队列.</p>
</li>
</ul>
<h4>挂起原因</h4>
<ol>
<li>终端用户的需要. 自己程序运行期间发现可疑问题.</li>
<li>父进程请求. 父进程希望挂起自己子进程.</li>
<li>负荷调节的需要. 实时系统工作负荷较重, 影响对实时任务的控制.</li>
<li>操作系统的需要. 检查运行中的资源使用情况或进行记账</li>
</ol>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-进程的结构"><header><h1><span class="taxon"></span>进程的结构 <a class="slug" href="/408/operating-system/进程的结构.html">[进程的结构]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/进程的结构.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><div style="display: flex; column-gap: 0.5em;">
<div>
<ul>
<li><span class="link local"><a href="/408/operating-system/进程控制块.html" title="进程控制块 PCB [408/operating-system/进程控制块]">进程控制块</a></span></li>
<li>数据段</li>
<li>程序段</li>
</ul>
</div>
<p style="text-align: center;"><img src="../../assets/process.svg" style="border-radius: 0.2em; width: 300px;"><br>进程的结构</p>
</div>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-中断和异常"><header><h1><span class="taxon"></span>中断和异常 <a class="slug" href="/408/operating-system/中断和异常.html">[中断和异常]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/中断和异常.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><h4>中断的作用</h4>
<ol>
<li>中断会使 CPU 由用户态变为内核态, OS 重新夺回对 CPU 的控制权. (硬件实现)</li>
<li>如果没有中断机制, 就无法进行并发.</li>
<li>中断是操作系统内核夺回 CPU 使用权的唯一途径 (用户态 $\to$ 内核态)</li>
</ol>
<h4>中断的类型</h4>
<ol>
<li><p>内中断 (异常、例外、陷入)</p>
<ol>
<li>与当前执行的指令有关, <em>中断信号来源于 CPU 内部</em>, 由某个指令引发的中断.</li>
<li>陷阱、陷入 [trap]: 由陷入指令引发的, 应用程序故意引发, 如: 系统调用.(陷入指令并非特权指令, 且需要在用户态下执行, 系统调用通过陷入指令完成)</li>
<li>故障 [fault]: 由错误条件引起, 可能被内核程序修复, CPU 使用权交还给应用程序. 如: 缺页故障.</li>
<li>终止 [abort]: 由致命错误引起, 内核程序无法修复该错误, 并且不会交还 CPU 使用权, 而是直接终止应用程序. 如: 除法指令除数为 0 (有争议)、非法使用特权指令.</li>
</ol>
</li>
<li><p>外中断 (也称中断)</p>
<ol>
<li>与当前执行的指令无关, <em>中断信号来源于 CPU 外部</em>.</li>
<li>时钟中断: 由时钟部件发来的中断信号, 时钟部件每隔一个时间片, 归给CPU 发送一个时钟中断信号.</li>
<li>I/O 中断: 由输入输出设备发来的中断信号.</li>
</ol>
</li>
</ol>
<p><em>异常会引起中断, 中断未必是异常引起的.</em></p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-内核"><header><h1><span class="taxon"></span>内核 <a class="slug" href="/408/operating-system/内核.html">[内核]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/内核.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>内核是计算机操作系统的核心程序, 始终对系统中的所有内容拥有完全控制权.</li>
<li>内核还负责防止和缓解不同进程之间的冲突. 它是始终驻留在内存中的操作系统代码部分, 并促进硬件和软件组件之间的交互.</li>
<li>完整的内核通过设备驱动程序控制所有硬件资源 (例如 I/O、内存、加密), 仲裁涉及此类资源的进程冲突, 并优化常用资源的利用率. <hint>例如 CPU 和缓存使用、文件系统和网络套接字. 在大多数系统中, 内核是启动时首先加载的程序之一 (在引导加载程序之后). 它处理启动的其余部分, 以及来自软件的内存、外围设备和输入 / 输出 (I/O) 请求, 将它们转换为中央处理单元的数据处理指令. </hint></li>
</ul>
<h3>内核的支撑功能</h3>
<h4>内中断的三种情况</h4>
<ol>
<li>陷阱 / 陷入 (Trap): 由应用程序主动引发</li>
<li>故障 (fault): 由错误条件引发</li>
<li>终止 (abort): 由致命错误引发</li>
</ol>
<p>$\textbf{Remark.}$ 内中断也叫异常 / 陷入 / 例外.</p>
<h3>内核的支撑功能</h3>
<ol>
<li>时钟管理</li>
<li>中断机制</li>
<li><span class="link local"><a href="/408/operating-system/原语.html" title="原语 [408/operating-system/原语]">原语</a></span><ul>
<li>由若干条指令组成</li>
<li>用来完成某个特定功能</li>
<li>执行过程不会被中断</li>
</ul>
</li>
</ol>
<p>$\textbf{Remark.}$ 进程控制的目的是实现进程的状态转换.</p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-进程同步机制"><header><h1><span class="taxon"></span>进程同步机制 <a class="slug" href="/408/operating-system/进程同步机制.html">[进程同步机制]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/进程同步机制.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><h3>进程间的相互关系</h3>
<h4>竞争关系 [Competition]</h4>
<ul>
<li>间接制约关系</li>
<li>解决方法 — 进程的 <em>互斥</em> [Mutual Exclusion, Mutex], 多个进程互斥地使用系统中共享的独占资源.</li>
</ul>
<h4>协作关系 [Collaboration]</h4>
<ul>
<li>直接制约关系</li>
<li>进程协作 — 某些进程为完成同一任务需要分工协作, 由于合作的每一个进程都是独立地以不可预知的速度推进, 这就需要相互协作的进程在某些协调点上协调各自的工作.</li>
<li>进程的 <em>同步</em> [Synchronization] 是解决进程间协作关系的手段.</li>
</ul>
<h3>进程同步机制</h3>
<p>在执行次序上进行协调 <hint>[同步]</hint>, 使并发执行的诸进程之间能按照一定的规则或时序共享系统资源 <hint>[互斥]</hint>, 并能很好地相互合作.</p>
<p>$\textbf{Remark.}$ 临界资源 [Critical Resource] 指任一个时间只允许一个进程使用的资源.</p>
<p>$\textbf{Remark.}$ 临界区 [Critical Section] 指每个进程中访问临界资源的那段代码.</p>
<h3>互斥的访问临界资源</h3>
<h4>访问过程</h4>
<ul>
<li>进入区: 尝试进入临界区, 成功则加锁 [lock].</li>
<li>临界区: 访问共享资源.</li>
<li>退出区: 解锁 [unlock] 唤醒其它阻塞进程.</li>
<li>剩余区: 其它代码.</li>
</ul>
<h4>访问临界资源的循环进程</h4>
<ul>
<li>进⼊区</li>
<li>临界区</li>
<li>退出区</li>
<li>剩余区</li>
</ul>
<h4>临界区准则</h4>
<ol>
<li><p>空闲让进. 当无进程处于临界区时, 表明临界资源处于空闲状态, 应允许一个请求进入临界区的进程立即进入自己的临界区, 以有效地利用临界资源.</p>
</li>
<li><p>忙则等待. 当已有进程进入临界区时, 表明临界资源正在被访问, 因而其它试图进入临界区的进程必须等待, 以保证对临界资源的互斥访问.</p>
</li>
<li><p>有限等待. 对要求访问临界资源的进程, 应保证在有限时间内能进入自己的临界区, 以免陷入“死等”状态.</p>
</li>
<li><p>让权等待. 当进程不能进入自己的临界区时, 应立即释放处理机, 以免进程陷入“忙等”状态.</p>
</li>
</ol>
<!--
### 用户级线程

#### 概念

1. 在用户空间实现, 用户级线程是与内核无关. 线程任务控制块设置在用户空间, 操作无须内核帮助.
1. 程序员自己写一个程序库实现逻辑上的线程, 操作系统的视角只看得到进程 (操作系统意识不到用户级线程的存在). 
1. 线程的管理工作由应用程序完成 (通过线程库). 

#### 优点

1. 线程切换不需要操作系统参与, 不需要转换到内核空间, 节省了模式切换开销.
1. 不同进程可以选择不同的调度算法.
1. 用户级线程实现与操作系统平台无关 
-->
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-信号量机制"><header><h1><span class="taxon"></span>信号量机制 <a class="slug" href="/408/operating-system/信号量机制.html">[信号量机制]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/信号量机制.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
<script>hljs.highlightAll();</script>
<style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>1965 年, 荷兰学者 Dijkstra 提出的信号量 [Semaphores] 机制是⼀种卓有成效的进程同步⼯具. 在长期且⼴泛的应⽤中, 信号量机制又得到了很⼤的发展, 它从整型信号量经记录型信号量, 进⽽发展 “信号量集” 机制. 现在, 信号量机制已被⼴泛地应⽤于单处理机和多处理机系统以及计算机⽹络中.</p>
<p>信号量是一个特殊变量, 一般使用 $S$ 表示. 最初信号量 $S$ 是表示可用资源数目的整型变量. 除初始化外, 只能对 $S$ 做两个原子操作</p>
<ul>
<li>$P(S)$ 操作 — $P(S)$ [<code>wait</code>].</li>
<li>$V(S)$ 操作 — $V(S)$ [<code>signal</code>].</li>
</ul>
<p>$\textbf{Remark.}$ $P,V$ 操作是操作系统内核的一部分, 是原语.</p>
<pre><code class="language-cpp">...
wait(S);    // 进入区, 申请打印机
访问共享资源; // 临界区, 访问打印机
signal(S); // 退出区, 释放打印机
...
</code></pre>
<p>整型信号量:</p>
<ul>
<li>$S>0$ 表示有 $S$ 个资源可用. $S=0$ 表示无资源可用.</li>
<li>违反 <em>让权等待</em>, 会发生忙等.</li>
</ul>
<pre><code class="language-c">// 整型信号量, 表示可用资源数
int S = 1;
// wait 原语, 相当于进入区
void wait(int S) {
    // 资源不够, 循环等待
    while (S &lt;= 0);
    S = S - 1;
}

// signal 原语, 相当于退出区
void signal(int S) {
    S = S + 1;
}
</code></pre>
<p>记录型信号量: 进程进入阻塞状态, 不会忙等.</p>
<pre><code class="language-c">// 记录型信号量定义
typedef struct {
    int value; // 剩余资源数量
    struct process *L; // PCB List, 进程等待队列
} semaphore;

void wait(semaphore S) {
    // 申请资源
    S.value--;
    if (S.value &lt; 0) {
        // bLock 原语阻塞进程 
        block(S.L);
    }
}

void signal(semaphore S) {
    // 释放资源
    S.value++;
    if (S.value &lt;= 0) {
        // wakeup 原语喚醒进程
        wakeup(S.L);
    }
}
</code></pre>
<!-- 
```cpp
P1() { S1; V(a); V(b); V(c); }
P1() { P(a); S2; V(d); }
...
void main () {
    semaphore a, b, c, d, e, f, g, h;
    a.value = b.value = c.value = d.value = e.value = f.value = g.value = h.value;
    cobegin
        P1(); P2(); P3(); P4(); P5(); ... 
    coend
}
```
-->
<p>$\textbf{Remark.}$ 一般情况下, 互斥信号量的初值为 1</p>
<p>$\textbf{Remark.}$ 互斥信号量的取值范围 <code>(-1, 0, 1)</code>.</p>
<ul>
<li><code>1</code>: 两个进程都没有进入临界区.</li>
<li><code>0</code>: 一个进程进入临界区运行.</li>
<li><code>-1</code>: 一个进程正在临界区运行, 另一个因等待而阻塞在等待队列中.</li>
</ul>
<h3>进程互斥</h3>
<p>$\textbf{Remark.}$ 互斥信号量 <code>mutex</code>, 初值为 <code>1</code>.</p>
<h3>进程同步</h3>
<p>$\textbf{Remark.}$ 同步信号量 <code>S</code>, 初始为 <code>0</code>.</p>
<p>总结:</p>
<ul>
<li>同步信号量出现在不同的同步进程中.</li>
<li>信号量的 $P$、$V$ 操作必须 <em>成对出现</em>.</li>
</ul>
<h3>前驱关系</h3>
<p>$\textbf{Example.}$</p>
<p style="text-align: center;"><img class="theme" src="../../assets/前驱.svg" style="border-radius: 0.2em; width: 300px;"></p>
<pre><code class="language-cpp">p1() { s1; V(a); V(b); }
p2() { p(a); s2; V(c); V(d); }
p3() { p(b); s3; V(e); }
p4() { p(c); s4; V(f); }
p5() { p(d); s5; V(g); }
p6() { p(e); p(f); p(g); s6; }

void main() {
    semaphore a, b, c, d, e, f, g;
    a.value = b.value = c.value = d.value = e.value = f.value = g.value = 0;
    cobegin 
        p1(); p2(); p3(); p4(); p5(); p6(); 
    coend
}
</code></pre>
<p>$\textbf{Example.}$ 公共汽车上有 1 名司机和 1 名售票员, 司机和售票员活动如下, 车辆运行规则是只有到站停车后售票员才能开门, 只有关门后司机才能启动车辆.初始状态是车辆停在起始站. 使用 P、V 原语描述车辆运行过程.</p>
<pre><code class="language-c">semaphore S1 = 1; // 车已停
semaphore S2 = 0; // 门已关

driver() {
    while (1) {
        P(S2);
        启动车辆;
        正常行驶;
        到站停车;
        V(S1);
    }
}

seller() {
    while (1) {
        售票;
        P(S1);
        开车门;
        关车门;
        V(S2);
    }
}
</code></pre>
<!-- 
```c
// (1) 互斥: 爸爸和妈妈. 同步: 爸爸和女儿, 妈妈和儿子.

semaphore mutex S = 1; // 盘子可用. 
semaphore apple = 0, banana = 0; // 苹果, 香蕉可用. 

father() {
    while (1) {
        P(S);
        放苹果;
        V(apple);
    }
}

daughter() {
    while (1) {
        P(apple);
        吃苹果;
        V(S);
    }
}

son() {
    while (1) {
        P(banana);
        吃香蕉;
        V(S);
    }
}

mother() {
    while (1) {
        P(S);
        放香蕉;
        V(banana);
    }
}
```

### 硬件同步机制

#### 关中断

关中断是实现互斥的最简单的⽅法之⼀. 在进⼊锁测试之前关闭中断, 直到完成锁测试并上锁之后才能打开中断. 这样, 进程在临界区执⾏期间, 计算机系统不响应中断, 从⽽不会引发调度, 也就不会发⽣进程或线程切换. 由此, 保证了对锁的测试和关锁操作的连续性和完整性, 有效地保证了互斥. 

#### 关中断的缺点

1. 滥⽤关中断权⼒可能导致严重后果. 
1. 关中断时间过长, 会影响系统效率, 限制了处理器交叉执⾏程序的能⼒. 
1. 关中断⽅法也不适⽤于多 CPU 系统, 因为在⼀个处理器上关中断并不能防⽌进程在其它处理器上执⾏相同的临界段代码.  -->
<blockquote>
<p>Also see: <span class="link external"><a href="https://www.cnblogs.com/Ligo-Z/p/14139991.html" title="https://www.cnblogs.com/Ligo-Z/p/14139991.html">https://www.cnblogs.com/Ligo-Z/p/14139991.html</a></span></p>
</blockquote>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-经典的进程同步问题"><header><h1><span class="taxon"></span>经典的进程同步问题 <a class="slug" href="/408/operating-system/经典的进程同步问题.html">[经典的进程同步问题]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/经典的进程同步问题.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/c.min.js"></script>
<script>hljs.highlightAll();</script>
<style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<h3>生产者消费者问题</h3>
<p>系统中有一组生产者进程和一组消费者进程, 生产者进程每次生产一个产品放入缓冲区, 消费者进程每次从缓冲区中取出一个产品并使用.</p>
<p>生产者、消费者共享一个初始为空、大小为 $n$ 的缓冲区.</p>
<ul>
<li>只有缓冲区没满时, 生产者才能把产品放入缓冲区, 否则必须等待. (同步关系, <code>empty = N</code>)</li>
<li>只有缓冲区不空时, 消费者才能从中取出产品, 否则必须等待. (同步关系, <code>full = 0</code>)</li>
<li>缓冲区是临界资源, 各进程必须互斥地访问. (互斥, <code>mutex</code>)</li>
</ul>
<pre><code class="language-c">semaphore mutex = 1;    // 缓冲区互斥信号量
semaphore empty = n;    // 缓冲区空闲数量
semaphore full = 0;     // 缓冲区物品数量

int in = 0, out = 0;

Process producer() {
    while (1) {
        produce an item nextp;
        P(empty);    // 请求缓冲区一个空位
        P(mutex);
        buffer[in] = nextp;
        in = (in + 1) % n;
        V(mutex);
        V(full);    // 缓冲区物品数量加一
    }
}

Process consumer() {
    while (1) {
        P(full);    // 请求缓冲区一个物品
        P(mutex);
        nextc = buffer[out];
        out = (out + 1) % n;
        V(mutex);
        V(empty);    // 缓冲区空位数量加一
        consume the item in nextc;
    }
}

void main() {
    cobegin    // 并发执行
        producer();
        consumer();
    coend
}
</code></pre>
<h3>哲学家进餐问题</h3>
<ul>
<li>系统中有 5 个哲学家进程, 5 位哲学家与左右邻居对其中间筷子的访问是互斥关系.</li>
</ul>
<pre><code class="language-c">
semaphore chopstick[5] = {1, 1, 1, 1, 1};    // mutex 

while (1) {
    P(chopstick[i]);
    P(chopstick[(i + 1) % 5]);
    ...
    eat;
    ...
    V(chopstick[i]);
    V(chopstick[(i + 1) % 5]);
    ...
    think;
    ...
}

</code></pre>
<p>$\textbf{Remark.}$ 假如五位哲学家同时饥饿而各自拿起左边的筷子时，就会使五个信号量  chopstick 均为 <code>0</code>, 引起死锁.</p>
<p>解决方法:</p>
<ol>
<li><p>至多只允许有四位哲学家同时去拿左边的筷子, 最终能保证至少有一位哲学家能够进餐, 并在用毕时能释放出他用过的两只筷子, 从而使更多的哲学家能够进餐.</p>
</li>
<li><p><em>仅当哲学家的左、右两只筷子均可用时, 才允许他拿起筷子进餐</em>.</p>
</li>
<li><p>规定奇数号哲学家先拿他左边的筷子, 然后再去拿右边的筷子; 而偶数号哲学家则相反. 最后总会有一位哲学家能获得两只筷子而进餐.</p>
</li>
</ol>
<h4>利用AND信号量机制解决哲学家进餐问题 (解决方法 2)</h4>
<pre><code class="language-c">
semaphore chopstick[5] = {1, 1, 1, 1, 1};

void P(int i) {
    while (1) {
        Swait(chopstick[i], chopstick[(i + 1) % 5])
        ...
        eat;
        ...
        Ssignal(chopstick[i], chopstick[(i + 1) % 5]);
        ...
        think;
        ...              
    }
}

void main() {
    cobegin
        for (int i = 0; i &lt; 5; i++) P(i);
    coend
}
</code></pre>
<h3>读者–写者问题</h3>
<ul>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出</li>
</ul>
<p>即, 若干读者和一个写者互斥. 两类进程: 写进程、读进程.</p>
<pre><code class="language-c">semaphore wmutex = 1;    // 是否有写者
semaphore rmutex = 1;    // 是否在读
int readercount = 0;

void reader() {
    while (1) {
        P(rmutex);
        readercount ++;
        if (readercount == 1) 
            P(wmutex);
        V(rmutex);
        read;
        P(rmutex);
        readercount --;
        if (readercount == 0) 
            V(wmutex);
        V(rmutex);
    }
}

void writer() {
    while (1) {
        P(wmutex);
        write;
        V(wmutex);
    }
}

void main() {
    cobegin
        reader(); writer();
    coend
}
</code></pre>
<h4>总结</h4>
<ul>
<li>分析问题, 弄清楚进程间的同步和互斥关系</li>
<li>设置信号量, 说明各信号量的含义和初值</li>
<li>写出包含P、V操作的程序描述</li>
</ul>
<!--
https://zhuanlan.zhihu.com/p/593795480
https://zhuanlan.zhihu.com/p/594093957
-->
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-处理机调度与死锁"><header><h1><span class="taxon"></span>处理机调度与死锁 <a class="slug" href="/408/operating-system/处理机调度与死锁.html">[处理机调度与死锁]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/处理机调度与死锁.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-处理机调度"><header><h1><span class="taxon"></span>处理机调度 <a class="slug" href="/408/operating-system/处理机调度.html">[处理机调度]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/处理机调度.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-处理机调度层次"><header><h1><span class="taxon"></span>处理机调度层次 <a class="slug" href="/408/operating-system/处理机调度层次.html">[处理机调度层次]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/处理机调度层次.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>在多道程序系统中, 调度的实质是⼀种资源分配, 处理机调度是对处理机资源进⾏分配. 处理机调度算法是指根据处理机分配策略所规定的处理机分配算法. 在多道批处理系统中,⼀个作业从提交到获得处理机执⾏, 直⾄作业运⾏完毕, 可能需要经历多级处理机调度, 下⾯先来了解处理机调度的层次.</p>
<ul>
<li><span class="link local"><a href="/408/operating-system/高级调度.html" title="高级调度 / 作业调度 [408/operating-system/高级调度]">高级调度</a></span></li>
<li><span class="link local"><a href="/408/operating-system/中级调度.html" title="中级调度 / 中程调度 / 内存调度 [408/operating-system/中级调度]">中级调度</a></span></li>
<li><span class="link local"><a href="/408/operating-system/低级调度.html" title="低级调度 / 进程调度 / 处理机调度 [408/operating-system/低级调度]">低级调度</a></span></li>
</ul>
<table><thead><tr><th>调度层次</th><th>状态转换</th><th>位置</th><th>别名</th></tr></thead><tbody>
<tr><td>高级</td><td>新建 $\to$ 就绪</td><td>外存 $\to$ 内存</td><td>作业调度</td></tr>
<tr><td>中级</td><td>就绪 $\to$ 静态就绪 <br> 阻塞 $\to$ 静态阻塞</td><td>内存 $\to$ 外存 [swap]</td><td>中程调度</td></tr>
<tr><td>低级</td><td>就绪 $\to$ 运行</td><td>内存</td><td>进程调度</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-处理机调度策略准则"><header><h1><span class="taxon"></span>处理机调度策略准则 <a class="slug" href="/408/operating-system/处理机调度策略准则.html">[处理机调度策略准则]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/处理机调度策略准则.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\str#1{\footnotesize{#1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$
$\gdef\type#1{~:~\texttt{#1}}$</p>
<h4>用户准则</h4>
<ul>
<li>作业周转时间短</li>
<li>响应时间快 (分时系统)</li>
<li>保证截止时间 (实时系统)</li>
<li>优先权</li>
</ul>
<h4>系统准则</h4>
<ul>
<li>吞吐量大, 处理机利用率高, 各类资源平衡利用.</li>
</ul>
<p>作业周转时间 $T =$ 后备队列等待调度时间 + 在就绪队列等待时间 + CPU上执行时间 + 等待 <code>I/O</code> 操作完成时间.</p>
<p>$$
\begin{aligned}
\hint{平均周转时间} ~ T &\spaces= \frac1n\sum_{n=1}^nT_i, \\
\hint{平均带权周转时间} ~ W &\spaces= \frac1n \sum_{n=1}^n \frac{T_i}{T_{S_i} ~ \hint{作业运行的时间}}
\end{aligned}
$$</p>
<p>周转时间 $=$ 作业完成时间 $−$ 作业提交时间 (到达时间).</p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-作业"><header><h1><span class="taxon"></span>作业 <a class="slug" href="/408/operating-system/作业.html">[作业]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/作业.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>是用户在一次解题或一个事务处理过程中要求计算机系统所做工作的集合.</p>
<ul>
<li>作业步. 每一个作业的步骤.</li>
<li>作业控制块 [JCB] 是作业的 <em>唯一标志</em>. 保存进行作业管理和调度信息. 对比 <span class="link local"><a href="/408/operating-system/进程控制块.html" title="进程控制块 PCB [408/operating-system/进程控制块]">进程控制块</a></span> [PCB].</li>
<li>作业的状态.<ul>
<li>后备状态</li>
<li>运行状态</li>
<li>完成状态</li>
</ul>
</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-调度算法"><header><h1><span class="taxon"></span>调度算法 <a class="slug" href="/408/operating-system/调度算法.html">[调度算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/调度算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\str#1{\footnotesize{#1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$
$\gdef\type#1{~:~\texttt{#1}}$</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-先来先服务"><header><h1><span class="taxon"></span>先来先服务 <a class="slug" href="/408/operating-system/先来先服务.html">[先来先服务]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/先来先服务.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><span class="link local"><a href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">FCFS</a></span> 是最简单的调度算法, 该算法既可⽤于作业调度, 也可⽤于进程调度. 当在作业调度中采⽤该算法时, 系统将按照作业到达的先后次序来进⾏调度, 或者说它是优先考虑在系统中等待时间最长的作业,⽽不管该作业所需执⾏时间的长短, 从后备作业队列中选择⼏个最先进⼊该队列的作业, 将它们调⼊内存, 为它们分配资源和创建进程. 然后把它放⼊就绪队列.</p>
<p>当在进程调度中采⽤ <span class="link local"><a href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">FCFS</a></span> 算法时, 每次调度是从就绪的进程队列中选择⼀个最先进⼊该队列的进程, 为之分配处理机, 使之投⼊运⾏. 该进程⼀直运⾏到完成或发⽣某事件⽽阻塞后, 进程调度程序才将处理机分配给其它进程.</p>
<p>顺便说明, <span class="link local"><a href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">FCFS</a></span> 算法在单处理机系统中已很少作为主调度算法, 但经常把它与其它调度算法相结合使⽤, 形成⼀种更为有效的调度算法. 例如, 可以在系统中按进程的优先级设置多个队列, 每个优先级⼀个队列, 其中每⼀个队列的调度都基于 <span class="link local"><a href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">FCFS</a></span> 算法.</p>
<h4>先来先服务 [FCFS, First Come First Served]</h4>
<ul>
<li>用于作业调度和进程调度.</li>
<li>选择一个或多个最先进入队列的作业 (进程).</li>
</ul>
<h4>优缺点:</h4>
<ul>
<li>利于长作业，不利于短作业.</li>
<li>利 CPU 繁忙型作业 (进程), 不利于 <code>I/O</code> 繁忙型作业 (进程).</li>
<li>适于批处理系统, 不适于分时系统.</li>
</ul>
<p>$\textbf{Example.}$ 先来先服务</p>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$1$</td><td style="text-align: center">$3$</td><td style="text-align: center">$4$</td><td style="text-align: center">$7$</td><td style="text-align: center">$6$</td><td style="text-align: center">$2$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$2$</td><td style="text-align: center">$5$</td><td style="text-align: center">$7$</td><td style="text-align: center">$12$</td><td style="text-align: center">$10$</td><td style="text-align: center">$2$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$3$</td><td style="text-align: center">$2$</td><td style="text-align: center">$12$</td><td style="text-align: center">$14$</td><td style="text-align: center">$11$</td><td style="text-align: center">$\frac{11}2$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$14$</td><td style="text-align: center">$18$</td><td style="text-align: center">$14$</td><td style="text-align: center">$\frac{14}4$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$9$</td><td style="text-align: center">$2.8$</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-短作业优先"><header><h1><span class="taxon"></span>短作业优先 <a class="slug" href="/408/operating-system/短作业优先.html">[短作业优先]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/短作业优先.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>短作业优先算法 SJF 是以作业的长短来计算优先级, 作业越短, 其优先级越⾼. 作业的长短是以作业所要求的运⾏时间来衡量的. SJF 算法可以分别⽤于作业调度和进程调度. 在把短作业优先调度算法⽤于作业调度时, 它将从外存的作业后备队列中选择若⼲个估计运⾏时间最短的作业, 优先将它们调⼊内存运⾏.</p>
<h4>短作业优先 [SJF, Shortest Job First]</h4>
<ul>
<li>用于作业调度和进程调度</li>
<li>选择估计运行时间最短的作业 (进程)</li>
</ul>
<h4>优缺点:</h4>
<ul>
<li>利于短作业 (进程)，不利于长作业 (进程)</li>
<li>没有考虑作业 (进程) 的紧迫程度</li>
<li>估计时间，没有真正的短作业 (进程) 优先</li>
</ul>
<p>$\textbf{Example.}$ 短作业优先</p>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$1$</td><td style="text-align: center">$3$</td><td style="text-align: center">$6$</td><td style="text-align: center">$9$</td><td style="text-align: center">$8$</td><td style="text-align: center">$8/3$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$2$</td><td style="text-align: center">$5$</td><td style="text-align: center">$13$</td><td style="text-align: center">$18$</td><td style="text-align: center">$16$</td><td style="text-align: center">$16/5$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$3$</td><td style="text-align: center">$2$</td><td style="text-align: center">$4$</td><td style="text-align: center">$6$</td><td style="text-align: center">$3$</td><td style="text-align: center">$3/2$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$9$</td><td style="text-align: center">$13$</td><td style="text-align: center">$9$</td><td style="text-align: center">$9/4$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$8$</td><td style="text-align: center">$2.1$</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-优先级调度算法"><header><h1><span class="taxon"></span>优先级调度算法 <a class="slug" href="/408/operating-system/优先级调度算法.html">[优先级调度算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/优先级调度算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>在优先级调度算法中, 基于作业的紧迫程度, 由外部赋予作业相应的优先级, 调度算法是根据该优先级进⾏调度的. 这样就可以保证紧迫性作业优先运⾏.优先级调度算法可作为作业调度算法, 也可作为进程调度算法. 当把该算法⽤于作业调度时, 系统是从后备队列中选择若⼲个优先级最⾼的作业装⼊内存.</p>
<h4>优先级调度 [PSA, Priority-Scheduling Algorithm]</h4>
<ul>
<li>用于作业调度和进程调度</li>
<li>选择优先权最高的作业 (进程)</li>
</ul>
<h4>两种类型</h4>
<ul>
<li>非抢占式优先权: 批处理系统、要求不严的实时系统.</li>
<li>抢占式优先权: 严格的实时系统、性能高的批处理、分时系统.</li>
</ul>
<p>$\textbf{Example.}$ 优先级调度</p>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">静态优先权</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$1$</td><td style="text-align: center">$3$</td><td style="text-align: center">$2$</td><td style="text-align: center">$8$</td><td style="text-align: center">$11$</td><td style="text-align: center">$10$</td><td style="text-align: center">$10/3$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$2$</td><td style="text-align: center">$5$</td><td style="text-align: center">$3$</td><td style="text-align: center">$11$</td><td style="text-align: center">$16$</td><td style="text-align: center">$14$</td><td style="text-align: center">$14/5$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$3$</td><td style="text-align: center">$2$</td><td style="text-align: center">$5$</td><td style="text-align: center">$16$</td><td style="text-align: center">$18$</td><td style="text-align: center">$15$</td><td style="text-align: center">$15/2$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$1$</td><td style="text-align: center">$4$</td><td style="text-align: center">$8$</td><td style="text-align: center">$4$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$9.4$</td><td style="text-align: center">$2.93$</td></tr>
</tbody></table>
<p>根据优先级是否可以动态改变，可将优先级分为静态优先级和动态优先级两种.</p>
<ul>
<li>静态优先级: 创建进程时确定, 之后一直不变.</li>
<li>动态优先级: 创建进程时有一个初始值, 之后会根据情况动态地调整优先级.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-高响应比优先"><header><h1><span class="taxon"></span>高响应比优先 <a class="slug" href="/408/operating-system/高响应比优先.html">[高响应比优先]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/高响应比优先.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\gdef\spaces#1{~ #1 ~}$
$\gdef\str#1{\footnotesize{#1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$
$\gdef\type#1{~:~\texttt{#1}}$</p>
<p>在批处理系统中, <span class="link local"><a href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">FCFS</a></span> 算法所考虑的只是作业的等待时间,⽽忽视了作业的运⾏时间.⽽ <span class="link local"><a href="/408/operating-system/短作业优先.html" title="短作业优先 [408/operating-system/短作业优先]">SJF</a></span> 算法正好与之相反, 只考虑作业的运⾏时间,⽽忽视了作业的等待时间.⾼响应⽐优先调度算法则是既考虑了作业的等待时间, 又考虑作业运⾏时间的调度算法, 因此既照顾了短作业, 又不致使长作业的等待时间过长, 从⽽改善了处理机调度的性能.</p>
<h4>高响应比优先 [HRRN, Highest Response Ratio Next]</h4>
<p>$$
\str{响应比} \spaces= \frac{\str{等待时间} + \str{要求服务时间} \hint{~~ = 响应时间}}{\str{要求服务时间}}
$$</p>
<ul>
<li>要综合考虑作业 / 进程的等待时间和要求服务的时间.</li>
<li>是否可抢占: 非抢占式的算法. 因此只有当前运行的作业 / 进程主动放弃处理机时, 才需要调度, 才需要计算响应比.</li>
<li>优缺点:<ul>
<li>综合考虑了等待时间和运行时间 (要求服务时间)</li>
<li>等待时间相同时, 要求服务时间短的优先 (SJF 的优点)</li>
<li>要求服务时间相同时, 等待时间长的优先 (FCFS 的优点)</li>
<li>对于长作业来说, 随着等待时间越来越久, 其响应比也会越来越大, 从而避免了长作业饥饿的问题.</li>
</ul>
</li>
<li>是否会导致饥饿: 不会.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-时间片轮转"><header><h1><span class="taxon"></span>时间片轮转 <a class="slug" href="/408/operating-system/时间片轮转.html">[时间片轮转]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/时间片轮转.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><h4>时间片轮转 [RR, Round-Robin]</h4>
<ul>
<li>算法规则: 按照各进程到达就绪队列的顺序, 轮流让各个进程执行一个时间片 (如 <code>100ms</code>). 若进程末在一个时间片内执行完, 则剥夺处理机, 将进程重新放到就绪队列队尾重新排队.</li>
<li>优点: 公平; 响应快, 适用于分时操作系统;</li>
<li>缺点: 由于高频率的进程切换, 因此有一定开销; 不区分任务的紧急程度.</li>
</ul>
<p>$\textbf{Example.}$</p>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$0$</td><td style="text-align: center">$15$</td><td style="text-align: center">$15$</td><td style="text-align: center">$15/4$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$1$</td><td style="text-align: center">$3$</td><td style="text-align: center">$1$</td><td style="text-align: center">$12$</td><td style="text-align: center">$11$</td><td style="text-align: center">$11/3$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$2$</td><td style="text-align: center">$5$</td><td style="text-align: center">$2$</td><td style="text-align: center">$18$</td><td style="text-align: center">$16$</td><td style="text-align: center">$16/5$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$3$</td><td style="text-align: center">$2$</td><td style="text-align: center">$3$</td><td style="text-align: center">$9$</td><td style="text-align: center">$6$</td><td style="text-align: center">$3$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$4$</td><td style="text-align: center">$17$</td><td style="text-align: center">$13$</td><td style="text-align: center">$13/4$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$12.2$</td><td style="text-align: center">$3.373..$</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon="Example"><details open><summary id="408-operating-system-调度算法-例"><header><h1><span class="taxon">Example. </span>调度算法 <a class="slug" href="/408/operating-system/调度算法-例.html">[调度算法-例]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/调度算法-例.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>$\textbf{Example.}$ 有 5 个批处理作业 (A、B、C、D、E) 几乎同时到达, 估计的运行时间分别为 2、4、6、8、10, 它们的优先级分别为 1、2、3、4、5 (1 为最低优先级). 对下面的每种调度算法, 分别计算作业的平均周转时间和平均带权周转时间.</p>
<ol>
<li>先来先服务 FCFS (作业到达顺序为 CDBEA).</li>
<li>短作业优先 SJF.</li>
<li>优先级调度算法 PSA.</li>
<li>时间片轮转 RR (时间片为 2 分钟).</li>
</ol>
<p>$\textbf{Solution.}$</p>
<ol>
<li>FCFS</li>
</ol>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$28$</td><td style="text-align: center">$30$</td><td style="text-align: center">$30$</td><td style="text-align: center">$15$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$14$</td><td style="text-align: center">$18$</td><td style="text-align: center">$18$</td><td style="text-align: center">$9/2$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$0$</td><td style="text-align: center">$6$</td><td style="text-align: center">$0$</td><td style="text-align: center">$6$</td><td style="text-align: center">$6$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$0$</td><td style="text-align: center">$8$</td><td style="text-align: center">$6$</td><td style="text-align: center">$14$</td><td style="text-align: center">$14$</td><td style="text-align: center">$7/4$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$0$</td><td style="text-align: center">$10$</td><td style="text-align: center">$18$</td><td style="text-align: center">$28$</td><td style="text-align: center">$28$</td><td style="text-align: center">$14/5$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$19.2$</td><td style="text-align: center">$5.01$</td></tr>
</tbody></table>
<ol start="2">
<li>SJF</li>
</ol>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$2$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$2$</td><td style="text-align: center">$6$</td><td style="text-align: center">$6$</td><td style="text-align: center">$3/2$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$0$</td><td style="text-align: center">$6$</td><td style="text-align: center">$6$</td><td style="text-align: center">$12$</td><td style="text-align: center">$12$</td><td style="text-align: center">$2$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$0$</td><td style="text-align: center">$8$</td><td style="text-align: center">$18$</td><td style="text-align: center">$20$</td><td style="text-align: center">$20$</td><td style="text-align: center">$5/2$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$0$</td><td style="text-align: center">$10$</td><td style="text-align: center">$20$</td><td style="text-align: center">$30$</td><td style="text-align: center">$30$</td><td style="text-align: center">$3$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$14$</td><td style="text-align: center">$2$</td></tr>
</tbody></table>
<ol start="3">
<li>PSA</li>
</ol>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$28$</td><td style="text-align: center">$30$</td><td style="text-align: center">$30$</td><td style="text-align: center">$15$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$24$</td><td style="text-align: center">$28$</td><td style="text-align: center">$28$</td><td style="text-align: center">$7$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$0$</td><td style="text-align: center">$6$</td><td style="text-align: center">$18$</td><td style="text-align: center">$24$</td><td style="text-align: center">$24$</td><td style="text-align: center">$4$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$0$</td><td style="text-align: center">$8$</td><td style="text-align: center">$10$</td><td style="text-align: center">$18$</td><td style="text-align: center">$18$</td><td style="text-align: center">$9/4$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$0$</td><td style="text-align: center">$10$</td><td style="text-align: center">$0$</td><td style="text-align: center">$10$</td><td style="text-align: center">$10$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$22$</td><td style="text-align: center">$5.85$</td></tr>
</tbody></table>
<ol start="4">
<li>RR</li>
</ol>
<table><thead><tr><th style="text-align: center">进程名</th><th style="text-align: center">到达</th><th style="text-align: center">服务</th><th style="text-align: center">开始</th><th style="text-align: center">完成</th><th style="text-align: center">周转</th><th style="text-align: center">带权周转</th></tr></thead><tbody>
<tr><td style="text-align: center">A</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$0$</td><td style="text-align: center">$2$</td><td style="text-align: center">$2$</td><td style="text-align: center">$1$</td></tr>
<tr><td style="text-align: center">B</td><td style="text-align: center">$0$</td><td style="text-align: center">$4$</td><td style="text-align: center">$2$</td><td style="text-align: center">$12$</td><td style="text-align: center">$12$</td><td style="text-align: center">$3$</td></tr>
<tr><td style="text-align: center">C</td><td style="text-align: center">$0$</td><td style="text-align: center">$6$</td><td style="text-align: center">$4$</td><td style="text-align: center">$20$</td><td style="text-align: center">$20$</td><td style="text-align: center">$3.3$</td></tr>
<tr><td style="text-align: center">D</td><td style="text-align: center">$0$</td><td style="text-align: center">$8$</td><td style="text-align: center">$6$</td><td style="text-align: center">$26$</td><td style="text-align: center">$26$</td><td style="text-align: center">$3.25$</td></tr>
<tr><td style="text-align: center">E</td><td style="text-align: center">$0$</td><td style="text-align: center">$10$</td><td style="text-align: center">$8$</td><td style="text-align: center">$30$</td><td style="text-align: center">$30$</td><td style="text-align: center">$3$</td></tr>
<tr><td style="text-align: center">平均</td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center"></td><td style="text-align: center">$18$</td><td style="text-align: center">$2.72$</td></tr>
</tbody></table>
<p>ABCDE BCDE CDE DE E</p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-死锁"><header><h1><span class="taxon"></span>死锁 <a class="slug" href="/408/operating-system/死锁.html">[死锁]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/死锁.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>系统中两个或两个以上的进程因共享资源而导致的一种僵持状态.</li>
<li>死锁是指系统中多个进程无限期地等待永远不会发生的条件.</li>
</ul>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-死锁的原因"><header><h1><span class="taxon"></span>死锁的原因 <a class="slug" href="/408/operating-system/死锁的原因.html">[死锁的原因]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/死锁的原因.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ol>
<li><em>对不可抢占资源的竞争</em>. 各进程对不可抢占 (剥夺) 的资源 (如打印机) 的竞争可能引起死锁, 对可抢占资源 (如 CPU) 的竞争是不会引起死锁的.</li>
<li><em>并发进程运行推进顺序不当</em>. 请求和释放资源的顺序不当也同样会导致死锁.</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-死锁产生的必要条件"><header><h1><span class="taxon"></span>死锁产生的必要条件 <a class="slug" href="/408/operating-system/死锁产生的必要条件.html">[死锁产生的必要条件]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/死锁产生的必要条件.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>产生死锁必须同时满足以下四个条件, 只要其中任一条件不成立, 死锁就不会发生.</p>
<ol>
<li><p><em>互斥条件</em>: 只有对必须互斥使用的资源的争抢才会导致死锁 (如: 哲学家的筷子、打印机设备). 像内存、扬声器这样可以同时让多个进程使用的资源是不会导致死锁的 (因为进程不用阻塞等待这种资源).</p>
</li>
<li><p><em>请求和保持条件</em>: 进程已经保持了至少一个资源, 但又提出了新的资源请求, 而该资源又被其他进程占有, 此时请求进程被阻塞, 但又对自己已有的资源保持不放.</p>
</li>
<li><p><em>不剥夺条件</em>: 进程所获得的资源在未使用完之前, 不能由其他进程强行夺走, 只能主动释放.</p>
</li>
<li><p><em>循环等待条件</em>: 存在一种进程资源的循环等待链, 链中的每一个进程已获得的资源同时被下一个进程所请求, 即成环.</p>
</li>
</ol>
<p>发生死锁时一定有循环等待, 但是发生循环等待时未必死锁 (循环等待是死锁的必要不充分条件). 如果同类资源数大于 1, 则即使有循环等待, 也未必发生死锁. <em>但如果系统中每类资源都只有一个, 那循环等待就是死锁的充分必要条件了</em>.</p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-死锁的处理策略"><header><h1><span class="taxon"></span>死锁的处理策略 <a class="slug" href="/408/operating-system/死锁的处理策略.html">[死锁的处理策略]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/死锁的处理策略.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>打破四个条件之一.</p>
<ol>
<li><p>把只能互斥使用的资源改造成允许共享使用, 则系统不会进入死锁状态. 如 SPOOLing 技术. 操作系统可以采用 SPOOLing 技术把独占设备在逻辑上改造成共享设备. 比如用 SPOOLing 技术将打印机改造成共享设备.</p>
<ul>
<li>该策略的缺点: 并不是所有的资源都可以改造成可共享使用的资源. 并且为了系统安全, 很多地方还必须保护这种互斥性. 因此, 很多时候都无法破坏互斥条件.</li>
</ul>
</li>
<li><p>破坏不剥夺条件:</p>
<ul>
<li><p>方案一: 当某个进程请求新的资源得不到满足时, 它必须立即释放保持的所有资源, 待以后需要时再重新申请. 也就是说, 即使某些资源尚未使用完, 也需要主动释放, 从而破坏了不可剥夺条件.</p>
</li>
<li><p>方案二: 当某个进程需要的资源被其他进程所占有的时候, 可以由操作系统协助, 将想要的资源强行剥夺. 这种方式一般需要考虑各进程的优先级 (比如: 剥夺调度方式, 就是将处理机资源强行剥夺给优先级更高的进程使用).</p>
</li>
<li><p>该策略的缺点: 实现起来比较复杂. 释放已获得的资源可能造成前一阶段工作的失效. 因此这种方法一般只适用于易保存和恢复状态的资源, 如 CPU.反复地申请和释放资源会增加系统开销, 降低系统吞吐量.若采用方案一, 意味着只要暂时得不到某个资源, 之前获得的那些资源都需要放弃, 以后再重新申请. 如果一直发生这样的情况, 就会导致进程饥饿.</p>
</li>
</ul>
</li>
<li><p>破坏循环等待条件</p>
<ul>
<li><p>可采用顺序资源分配法. 首先给系统中的资源编号, 规定每个进程必须按编号递增的顺序请求资源, 同类资源 (即编号相同的资源) 一次申请完.</p>
</li>
<li><p>该策略的缺点: 不方便增加新的设备, 因为可能需要重新分配所有的编号. 进程实际使用资源的顺序可能和编号递增顺序不一致, 会导致资源浪费. 必须按规定次序申请资源, 用户编程麻烦.</p>
</li>
</ul>
</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-处理死锁的⽅法"><header><h1><span class="taxon"></span>处理死锁的⽅法 <a class="slug" href="/408/operating-system/处理死锁的⽅法.html">[处理死锁的⽅法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/处理死锁的⽅法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ol>
<li><p>预防死锁. 这是一种较简单和直观的事先预防方法. 该方法是通过设置某些限制条件, 去破坏产生死锁四个必要条件中的一个或几个来预防产生死锁. 预防死锁是一种较易实现的方法, 已被广泛使用.</p>
</li>
<li><p>避免死锁. 同样是属于事先预防策略, 但它并不是事先采取各种限制措施, 去破坏产生死锁的四个必要条件, 而是在资源的动态分配过程中, 用 <span class="link local"><a href="/408/operating-system/银行家算法.html" title="银行家算法 [408/operating-system/银行家算法]">某种方法</a></span> 防止系统进入不安全状态, 从而可以避免发生死锁.</p>
</li>
<li><p>检测死锁. 这种方法无须事先采取任何限制性措施, 允许进程在运行过程中发生死锁. 但可通过检测机构及时地检测出死锁的发生, 然后采取适当的措施, 把进程从死锁中解脱出来.</p>
</li>
<li><p>解除死锁. 当检测到系统中已发生死锁时, 就采取相应措施, 将进程从死锁状态中解脱出来. 常用的方法是撤消一些进程, 回收它们的资源, 将它们分配给已处于阻塞状态的进程, 使其能继续运行.</p>
</li>
</ol>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-银行家算法"><header><h1><span class="taxon"></span>银行家算法 <a class="slug" href="/408/operating-system/银行家算法.html">[银行家算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/银行家算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><h4>核心思想</h4>
<p>在进程提出资源申请时, 先预判此次分配是否会导致系统进入不安全状态. 如果会进入不安全状态, 就暂时不答应这次请求, 让该进程先阻塞等待.</p>
<p>算法步骤:</p>
<ol>
<li>检查次此次申请是否超过了之前声明的最大需求数.</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求.</li>
<li>试探着分配, 更改各数据结构.</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态.</li>
</ol>
<p>安全性算法步骤:</p>
<ul>
<li>检查当前的剩余可用资源是否能满足某个进程的最大需求, 如果可以, 就把该进程加入安全序列, 并把该进程持有的资源全部回收.</li>
<li>不断重复上述过程, 看最终是否能让所有进程都加入安全序列.</li>
</ul>
<table><thead><tr><th>记号</th><th>含义</th></tr></thead><tbody>
<tr><td><code>Max</code></td><td>每个客户最大贷款额度.</td></tr>
<tr><td><code>Allocation</code></td><td>每个客户已经贷款的额度.</td></tr>
<tr><td><code>Need</code></td><td>每个客户尚需贷款的额度.</td></tr>
<tr><td><code>Available</code></td><td>银行家还可用于贷款的额度.</td></tr>
<tr><td><code>Work</code></td><td>同 <code>Available</code></td></tr>
<tr><td><code>Finish</code></td><td>是否结束</td></tr>
</tbody></table>
<p>$\textbf{Example.}$</p>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center">Max</th><th style="text-align: center">Allocation</th><th style="text-align: center">Need</th><th style="text-align: center">Available</th></tr></thead><tbody>
<tr><td style="text-align: center"></td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td></tr>
<tr><td style="text-align: center">$P_0$</td><td style="text-align: center">7   5   3</td><td style="text-align: center">0   1   0</td><td style="text-align: center">7   4   3</td><td style="text-align: center">3   3   2</td></tr>
<tr><td style="text-align: center">$P_1$</td><td style="text-align: center">3   2   2</td><td style="text-align: center">2   0   0</td><td style="text-align: center">1   2   2</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">$P_2$</td><td style="text-align: center">9   0   2</td><td style="text-align: center">3   0   2</td><td style="text-align: center">6   0   0</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">$P_3$</td><td style="text-align: center">2   2   2</td><td style="text-align: center">2   1   1</td><td style="text-align: center">0   1   1</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">$P_4$</td><td style="text-align: center">4   3   3</td><td style="text-align: center">0   0   2</td><td style="text-align: center">4   3   1</td><td style="text-align: center"></td></tr>
</tbody></table>
<ol>
<li>$T_0$ 时刻的安全性: 利用安全性算法对 $T_0$ 时刻的资源分配情况进行分析可知, 在 $T_0$ 时刻存在着一个安全序列 $P_1, P_3, P_4, P_2, P_0$, 故系统是安全的.</li>
</ol>
<table><thead><tr><th style="text-align: center"></th><th style="text-align: center">Max</th><th style="text-align: center">Need</th><th style="text-align: center">Allocation</th><th style="text-align: center">Work + Available</th><th style="text-align: center">Finish</th></tr></thead><tbody>
<tr><td style="text-align: center"></td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td><td style="text-align: center">A   B   C</td><td style="text-align: center"></td></tr>
<tr><td style="text-align: center">$P_1$</td><td style="text-align: center">3   2   2</td><td style="text-align: center">1   2   2</td><td style="text-align: center">2   0   0</td><td style="text-align: center">5   3   2</td><td style="text-align: center">true</td></tr>
<tr><td style="text-align: center">$P_3$</td><td style="text-align: center">2   2   2</td><td style="text-align: center">0   1   1</td><td style="text-align: center">2   1   1</td><td style="text-align: center">7   4   3</td><td style="text-align: center">true</td></tr>
<tr><td style="text-align: center">$P_4$</td><td style="text-align: center">4   3   3</td><td style="text-align: center">4   3   1</td><td style="text-align: center">0   0   2</td><td style="text-align: center">7   4   5</td><td style="text-align: center">true</td></tr>
<tr><td style="text-align: center">$P_2$</td><td style="text-align: center">9   0   2</td><td style="text-align: center">6   0   0</td><td style="text-align: center">3   0   2</td><td style="text-align: center">10   4   7</td><td style="text-align: center">true</td></tr>
<tr><td style="text-align: center">$P_0$</td><td style="text-align: center">7   5   3</td><td style="text-align: center">7   4   3</td><td style="text-align: center">0   1   0</td><td style="text-align: center">10   5   7</td><td style="text-align: center">true</td></tr>
</tbody></table>
<ol start="2">
<li>$P_1$ 请求资源: $P_1$ 发出请求向量 $\text{Request}_1(1,0,2)$, 系统按银行家算法进行检查:<ol>
<li>$\text{Request}_1(1, 0, 2) \leqslant \text{Need}_1(1,2,2)$</li>
<li>$\text{Request}_1(1, 0, 2) \leqslant \text{Available}(3,3,2)$</li>
<li>系统先假定可为 $P$, 分配资源，并修改 $\text{Available}$, $\text{Allocation}$ 和 $\text{Need}$ 向量.</li>
<li>再利用安全性算法检查此时系统是否安全.</li>
</ol>
</li>
</ol>
<p>由所进行的安全性检查得知, 可以找到一个安全序列 $P_1, P_3, P_4, P_2, P_0$. 因此, 系统是安全的, 可以立即将 $P_1$ 所申请的资源分配给它.</p>
<ol start="3">
<li><p>$P_4$ 请求资源: $P_4$ 发出请求向量 $\text{Request}_4(3, 3,0)$, 系统按银行家算法进行检查:</p>
<ol>
<li>$\text{Request}_4(3, 3, 0) ≤ \text{Need}_4(4, 3, 1)$</li>
<li>$\text{Request}_4(3, 3,0) > \text{Available}(2, 3,0)$, 让 $P_4$ 等待.</li>
</ol>
</li>
<li><p>$P_0$ 请求资源: $P_0$ 发出请求向量 $\text{Request}_0(0,2,0)$, 系统按银行家算法进行检查:</p>
<ol>
<li>$\text{Request}_0(0,2,0) \leqslant \text{Need}_0(7,4,3)$</li>
<li>$\text{Request}_0(0,2,0) \leqslant \text{Available}(2,3,0)$</li>
<li>系统暂时先假定可为 $P_0$ 分配资源, 并修改有关数据.</li>
</ol>
</li>
<li><p>进行安全性检查: 可用资源 $\text{Available}(2, 1, 0)$ 已不能满足任何进程的需要, 故系统进入不安全状态, 此时系统不分配资源.</p>
</li>
</ol>
</details></section></p>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-存储器管理"><header><h1><span class="taxon"></span>存储器管理 <a class="slug" href="/408/operating-system/存储器管理.html">[存储器管理]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/存储器管理.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-存储器的层次结构"><header><h1><span class="taxon"></span>存储器的层次结构 <a class="slug" href="/408/operating-system/存储器的层次结构.html">[存储器的层次结构]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/存储器的层次结构.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><table><thead><tr><th>多级存储器结构</th><th></th></tr></thead><tbody>
<tr><td>CPU 寄存器</td><td>寄存器</td></tr>
<tr><td>主存</td><td>高速缓存, 主存, 磁盘缓存 [<code>buffer</code>]</td></tr>
<tr><td>辅存</td><td>磁盘, 可移动存储介质</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>缓存</th><th>速度匹配</th><th>物理</th></tr></thead><tbody>
<tr><td>高速缓存</td><td>CPU $\lrarr$ 主存</td><td>是</td></tr>
<tr><td>磁盘缓存</td><td>主存 $\lrarr$ 磁盘</td><td>否, 是主存的一部分区域</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-装入和链接"><header><h1><span class="taxon"></span>程序的装入和链接 <a class="slug" href="/408/operating-system/装入和链接.html">[装入和链接]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/装入和链接.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>物理地址: 内存由若干存储单元构成, 每个存储单元有个编号, 也称绝对地址.</li>
<li>物理空间: 物理地址的集合, 也称绝对地址空间或存储空间.</li>
<li>逻辑地址: 每个目标程序一般从 <code>0</code> 开始编址, 也称相对地址.</li>
<li>逻辑空间: 逻辑地址的集合, 也称相对地址空间或地址空间.</li>
</ul>
<table><thead><tr><th>装入方式</th><th>装入时机</th><th>地址变化</th><th>优点</th><th>缺点</th><th>环境</th></tr></thead><tbody>
<tr><td>绝对装入⽅式</td><td>编程时</td><td>编译期</td><td>装入简单</td><td>依赖硬件结构</td><td>单道程序环境</td></tr>
<tr><td>可重定位装入⽅式</td><td>运行前</td><td>装入前静态重定位</td><td>不依赖硬件</td><td>必须有连续空间</td><td>多道程序环境</td></tr>
<tr><td>动态运⾏时的装入⽅式</td><td>运行中</td><td>运行时完成</td><td>不需要连续空间</td><td>OS 开销大</td><td>多道程序环境</td></tr>
</tbody></table>
<br>
<table><thead><tr><th>链接方式</th><th>链接时机</th><th>优点</th></tr></thead><tbody>
<tr><td>静态链接</td><td>事先进⾏链接, 不再拆开</td><td>稳定</td></tr>
<tr><td>装入时动态链接</td><td>装入内存时, 边装入边链接</td><td>便于修改和更新, 便于实现对⽬标模块的共享</td></tr>
<tr><td>运⾏时动态链接</td><td>对某些模块的链接推迟到程序执⾏时才进⾏</td><td>加快程序的装入过程, 节省⼤量的内存空间</td></tr>
</tbody></table>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-连续分配存储管理"><header><h1><span class="taxon"></span>连续分配存储管理⽅式 <a class="slug" href="/408/operating-system/连续分配存储管理.html">[连续分配存储管理]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/连续分配存储管理.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>连续分配⽅式是最早出现的⼀种存储器分配⽅式, 曾被⼴泛应⽤于上世纪 60~80 年代的 OS 中, 该分配⽅式为⼀个⽤户程序分配⼀个连续的内存空间, 即程序中代码或数据的逻辑地址相邻, 体现在内存空间分配时物理地址的相邻. 连续分配⽅式可分为四类: 单⼀连续分配、 固定分区分配、 动态分区分配以及动态可重定位分区分配算法四种⽅式.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-单⼀连续分配"><header><h1><span class="taxon"></span>单⼀连续分配 <a class="slug" href="/408/operating-system/单⼀连续分配.html">[单⼀连续分配]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/单⼀连续分配.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>分配思想: 内存分为 OS 区和用户区. 用户区仅允许分配一个作业.</li>
<li>数据结构: 起始地址, 大小.</li>
<li>分配和回收: 用户区空闲则分配. 作业运行完回收.</li>
<li>优点: 简单.</li>
<li>缺点: 单作业. 主存利用率不高. 程序是否运行受到主存大小的限制.</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-固定分区分配"><header><h1><span class="taxon"></span>固定分区分配 <a class="slug" href="/408/operating-system/固定分区分配.html">[固定分区分配]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/固定分区分配.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>分配思想:<ul>
<li>预先将主存空间分成若干个区域.</li>
<li>每个区域被称为一个分区.</li>
<li>分区大小可以相等, 也可以不相等.</li>
<li>每个分区只能装一个作业.</li>
</ul>
</li>
<li>数据结构: 分区分配表. 记录分区分配情况.</li>
<li>分配和回收: 如果有空闲区, 就分配给作业. 按分区回收, 将分区分配表中对应条目的状态置为未分配.</li>
<li>优点: 适合多道程序环境. 实现简单.</li>
<li>缺点: 有内零头, 主存利用率不高. 程序是否运行受到分区大小的限制.</li>
</ul>
<p>$\textbf{Remark.}$ 内零头和外零头都是指分区内未被利用的空间. 但是外零头可以分配空间.</p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-动态分区"><header><h1><span class="taxon"></span>动态分区 <a class="slug" href="/408/operating-system/动态分区.html">[动态分区]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/动态分区.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><ul>
<li>分配思想: 内存不预先划分好. 根据作业的大小分配内存. 如果有空闲区满足作业大小的需求就分配. \</li>
<li>数据结构: 利用空闲分区表记录空闲区情况. 利用已分配分区表记录内存分配情况. \</li>
<li>分配和回收:<ol>
<li>修改 $F_1$ 的长度. $F_1$ 长度 + 回收区长度.</li>
<li>修改 $F_2$ 的始地址和长度. 回收区长度 + $F_2$ 长度.</li>
<li>修改 $F_1$ 的长度, 删除 $F_2$. $F_1$ + 回收区 + $F_2$ 长度.</li>
<li>新增一条记录, 分别是回收区的始地址和长度.</li>
</ol>
</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-动态可重定位分区"><header><h1><span class="taxon"></span>动态可重定位分区分配 <a class="slug" href="/408/operating-system/动态可重定位分区.html">[动态可重定位分区]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/动态可重定位分区.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>可以理解成 <span class="link local"><a href="/408/operating-system/动态分区.html" title="动态分区 [408/operating-system/动态分区]">动态分区分配</a></span> 的紧凑化版本.</p>
</details></section>
<section class="block hide-metadata" data-taxon="Example"><details open><summary id="408-operating-system-连续分配存储管理⽅式-例"><header><h1><span class="taxon">Example. </span>连续分配存储管理 <a class="slug" href="/408/operating-system/连续分配存储管理⽅式-例.html">[连续分配存储管理⽅式-例]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/连续分配存储管理⽅式-例.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>用可变分区方式管理内存时, 假定内存中按地址顺序依次有 5 个空闲区, 大小为 32、 10、 5、 228、 100, 单位为 KB, 现有 5 个作业, 各需内存 11、 10、 108、 28、 115, 若采用首次适用分配算法能全部装入吗? 怎样才能装入?</p>
<table><thead><tr><th>请求队列</th><th>⾸次适应算法</th></tr></thead><tbody>
<tr><td>初始</td><td>32 10 5 228 100</td></tr>
<tr><td>11</td><td><em>21</em> 10 5 228 100</td></tr>
<tr><td>10</td><td><em>11</em> 10 5 228 100</td></tr>
<tr><td>108</td><td>11 10 5 <em>120</em> 100</td></tr>
<tr><td>28</td><td>11 10 5 <em>92</em> 100</td></tr>
<tr><td>115</td><td>失败</td></tr>
</tbody></table>
<p>因为失败的原因是缺乏大分区, 所以我们考虑最佳适应算法. 如下所示.</p>
<table><thead><tr><th>请求队列</th><th>最佳适应算法</th></tr></thead><tbody>
<tr><td>初始</td><td>32 10 5 228 100</td></tr>
<tr><td>11</td><td><em>21</em> 10 5 228 100</td></tr>
<tr><td>10</td><td>21 <em>0</em> 5 228 100</td></tr>
<tr><td>108</td><td>21 0 5 <em>120</em> 100</td></tr>
<tr><td>28</td><td>21 0 5 120 <em>72</em></td></tr>
<tr><td>115</td><td>21 0 5 <em>5</em> 72</td></tr>
</tbody></table>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-离散分配"><header><h1><span class="taxon"></span>离散分配 <a class="slug" href="/408/operating-system/离散分配.html">[离散分配]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/离散分配.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-分页存储管理⽅式"><header><h1><span class="taxon"></span>分页存储管理⽅式 <a class="slug" href="/408/operating-system/分页存储管理⽅式.html">[分页存储管理⽅式]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/分页存储管理⽅式.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
img {
  border-radius: 0.2em; 
  width: 400px;
}
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>$\gdef\str#1{{\footnotesize #1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$</p>
<p>在该⽅式中, 将 <em>⽤户程序的地址空间</em> 分为若⼲个固定⼤⼩的区域, 称 “页” [page] 或 “页⾯”. 典型的页⾯⼤⼩为 1KB. 相应地, 也 <em>将内存空间</em> 分为若⼲个物理块 [block] 或页框 [frame], 页和块的⼤⼩相同. 这样可将⽤户程序的任⼀页放⼊任⼀物理块中, 实现了离散分配.</p>
<p>$$
\hint{页号} ~ P = \bigg\lfloor \frac{\hint{逻辑地址} ~ A}{\hint{页⾯⼤⼩} ~ L} \bigg\rfloor, \quad
\hint{页内地址} ~ d = \hint{逻辑地址} ~ A \mod \hint{页⾯⼤⼩} ~ L
$$</p>
<p>$\textbf{Example.}$ 逻辑地址为 2500, 每页大小为 1KB, 页表如下. 求物理地址.</p>
<div style="display: flex; width: 100%;">
  <div style="flex: 1; padding: 0 10px;">
<table><thead><tr><th>页号</th><th>块号</th></tr></thead><tbody>
<tr><td>0</td><td>2</td></tr>
<tr><td>1</td><td>3</td></tr>
<tr><td>2</td><td>8</td></tr>
</tbody></table>
  </div>
  <div style="flex: 2.5; padding: 0 10px;">
<p>$P = \lfloor \frac{2500}{1 ~\text{K}} \rfloor = 2, d = 2500 \mod 1 ~\text{KB} = 452$</p>
<p>$ \str{物理地址} = \hint{块号} ~ 8 \times \hint{页表长度} ~ 1 ~\text{K} + 452 = 8644$</p>
  </div>
</div>
<div style="text-align: center; ">
<p><img src="/assets/分页系统的地址变换机构.png" title="" alt=""></p>
</div>
<p>$\textbf{Remark.}$ 为了提⾼地址变换速度, 可在地址变换机构中增设⼀个具有并⾏查寻能⼒的特⾼速缓冲寄存器, 又称为 “联想寄存器” [Associative Memory], 或称为 <em>“快表”</em>.</p>
<div style="text-align: center; ">
<p><img src="/assets/具有快表的地址变换机构.png" title="" alt=""></p>
</div>
<h4>基本分页存储管理的缺点: 将用户作业物理划分页</h4>
<ul>
<li>不方便共享</li>
<li>不方便信息保护</li>
<li>不方便动态增长</li>
<li>不方便动态链接</li>
</ul>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-分段存储管理⽅式"><header><h1><span class="taxon"></span>分段存储管理⽅式 <a class="slug" href="/408/operating-system/分段存储管理⽅式.html">[分段存储管理⽅式]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/分段存储管理⽅式.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
img {
  border-radius: 0.2em; 
  width: 400px;
}
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>$\gdef\str#1{{\footnotesize #1}}$
$\gdef\hint#1{{\color{gray}{\str{#1}}}}$</p>
<p>这是为了满⾜⽤户要求⽽形成的⼀种存储管理⽅式. 它把⽤户程序的地址空间分为若⼲个⼤⼩不同的段, 每段可定义⼀组相对完整的信息. 在存储器分配时, 以段为单位, 这些段在内存中可以不相邻接, 所以也同样实现了离散分配.</p>
<p>作业的逻辑地址按照 <em>逻辑意义</em> 划分成段</p>
<ul>
<li>每一段从 0 开始编址，所有段从 0 开始编号</li>
<li>段长由逻辑信息的长度决定</li>
<li>每一段在内存中连续存储</li>
</ul>
<p>段的长度由相应的逻辑信息组的长度决定, 因此各段的长度并不相等. 整个作业的地址空间由于被分成多个段, 所以呈现出⼆维特性, 亦即, 每个段既包含了⼀部分地址空间, 又标识了逻辑关系. 其逻辑地址由段号 (段名) 和段内地址所组成.</p>
<div style="text-align: center; ">
<p><img src="/assets/分段系统的地址变换过程.png" title="" alt=""></p>
</div>
<div style="display: flex; width: 100%;">
  <div style="flex: 1; padding: 0 10px;">
<table><thead><tr><th>段号</th><th>基址</th><th>段长</th></tr></thead><tbody>
<tr><td>$n$</td><td>$b$</td><td>$\ell$</td></tr>
</tbody></table>
  </div>
  <div style="flex: 3; padding: 0 10px;">
<p>逻辑地址 $[\hint{段号} ~ a, \hint{段内地址} ~ f]$ 的物理地址是 $\hint{段号对应的基址} ~ b + \hint{段内地址} ~ f$. 若 $ \hint{段内地址} ~ f &gt; \hint{段长} ~ \ell$, 则段长越界, 非法.</p>
</div>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-段页式存储管理⽅式"><header><h1><span class="taxon"></span>段页式存储管理⽅式 <a class="slug" href="/408/operating-system/段页式存储管理⽅式.html">[段页式存储管理⽅式]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/段页式存储管理⽅式.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>这是分页和分段两种存储管理⽅式相结合的产物. 它同时具有两者的优点, 是⽬前应⽤较⼴泛的⼀种存储管理⽅式.</p>
<p>分页系统以页⾯作为内存分配的基本单位, 能有效地提⾼内存利⽤率,⽽分段系统以段作为内存分配的基本单位, 它能够更好地满⾜⽤户多⽅⾯的需要. 如果能对两种存储管理⽅式 “各取所长”, 则可形成⼀种新的存储器管理⽅式—段页式存储管理⽅式. 这种新的系统既具有分段系统的便于实现、 分段可共享、 易于保护、 可动态链接等⼀系列优点,又能像分页系统那样, 很好地解决内存的外部碎⽚问题.</p>
<p>段页式系统的基本原理是分段和分页原理的结合, 即 <em>先将⽤户程序分成若⼲个段, 再把每个段分成若⼲个页, 并为每⼀个段赋予⼀个段名.</em></p>
<p style="text-align: center;"><img src="../../assets/段表和页表的地址映射.png" style="border-radius: 0.2em; width: 400px;"></p>
<p><em>在段页式系统中, 为了实现从逻辑地址到物理地址的变换, 系统中需要同时配置段表和页表.</em> 段表的内容与分段系统略有不同, 它不再是内存始址和段长, 而是页表始址和页表长度. 上图示出了利用段表和页表进行从用户地址空间到物理 (内存) 空间的映射.</p>
<p style="text-align: center;"><img src="../../assets/段页式系统中的地址变换机构.png" style="border-radius: 0.2em; width: 400px;"></p>
</details></section></p>
<p>分页和分段的相同点:</p>
<ul>
<li>都是为了提高内存利用率, 产生较少的内存碎片.</li>
<li>页和段都是离散存储的, 都是离散分配内存的方式.</li>
<li>每个页和段中的内存是连续的.</li>
</ul>
<p>分页和分段的不同点:</p>
<ul>
<li>页是信息的物理单位, 段则是信息的逻辑单位.</li>
<li>页的大小固定且由系统决定, 段的长度不固定.</li>
<li>分页的作业地址空间是一维的、分段是二维的.</li>
<li>页为了系统管理需要, 段为了用户的需要.</li>
<li>一般段比页长, 段表比页表短, 方便查找.</li>
</ul>
</details></section></p>
</details></section>
<section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-虚拟存储器"><header><h1><span class="taxon"></span>虚拟存储器 <a class="slug" href="/408/operating-system/虚拟存储器.html">[虚拟存储器]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/虚拟存储器.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>各种 <span class="link local"><a href="/408/operating-system/存储器管理.html" title="存储器管理 [408/operating-system/存储器管理]">存储器管理</a></span> ⽅式有⼀个共同的特点, 即它们都要求将⼀个作业全部装⼊内存后⽅能运⾏. 于是, 出现了下⾯这样两种情况:</p>
<ol>
<li>有的作业很⼤, 其所要求的内存空间超过了内存总容量, 作业不能全部被装⼊内存, 致使该作业⽆法运⾏;</li>
<li>有⼤量作业要求运⾏, 但由于内存容量不⾜以容纳所有这些作业, 只能将少数作业装⼊内存让它们先运⾏,⽽将其它⼤量的作业留在外存上等待.</li>
</ol>
<p>出现上述两种情况的原因都是由于内存容量不够⼤. ⼀个显⽽易见的解决⽅法是从物理上增加内存容量, 但这往往会受到机器⾃⾝的限制, ⽽且⽆疑要增加系统成本, 因此这种⽅法是受到⼀定限制的. 另⼀种⽅法是从逻辑上扩充内存容量, 这正是虚拟存储技术所要解决的主要问题.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-常规存储器管理⽅式的特征"><header><h1><span class="taxon"></span>常规存储器管理⽅式的特征 <a class="slug" href="/408/operating-system/常规存储器管理⽅式的特征.html">[常规存储器管理⽅式的特征]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/常规存储器管理⽅式的特征.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p><span class="link local"><a href="/408/operating-system/存储器管理.html" title="存储器管理 [408/operating-system/存储器管理]">传统存储器管理⽅式</a></span> 全都具有如下两个共同的特征:</p>
<ol>
<li>⼀次性, 是指作业必须⼀次性地全部装⼊内存后⽅能开始运⾏. 在传统存储器管理⽅式中, ⽆⼀例外地要求先将作业全部装⼊内存后⽅能运⾏. 正是这⼀特征导致了⼤作业⽆法在⼩内存中运⾏, 以及⽆法进⼀步提⾼系统的多道程序度, 直接限制了对处理机的利⽤率和系统的吞吐量的提⾼. 事实上, 许多作业在运⾏时, 并⾮需要⽤到全部程序和数据,如果⼀次性地装⼊其全部程序和数据, 显然也是对内存空间的⼀种浪费.</li>
<li>驻留性, 是指作业被装⼊内存后, 整个作业都⼀直驻留在内存中, 其中任何部分都不会被换出, 直⾄作业运⾏结束. 尽管运⾏中的进程会因 I/O 等原因⽽被阻塞, 可能处于长期等待状态, 或者有的程序模块在运⾏过⼀次后就不再需要 (运⾏) 了, 它们都仍将驻留在内存中, 继续占⽤宝贵的内存资源.</li>
</ol>
<p>由此可以看出, 上述的⼀次性及驻留性特征使得许多在程序运⾏中不⽤或暂时不⽤的程序 (数据) 占据了⼤量的内存空间,⽽⼀些需要运⾏的作业又⽆法装⼊运⾏, 显然, 这是在浪费宝贵的内存资源. 现在要研究的问题是: <em>⼀次性及驻留性特征是否是程序在运⾏时所必需的和不可改变的.</em></p>
</details></section></p>
<p>当⽤户看到⾃⼰的程序能在系统中正常运⾏时, 他会认为, 该系统所具有的内存容量⼀定⽐⾃⼰的程序⼤, 或者说,⽤户所感觉到的内存容量会⽐实际内存容量⼤得多. 但⽤户所看到的⼤容量只是⼀种错觉, 是虚的, 故⼈们把这样的存储器称为虚拟存储器.</p>
<p>综上所述, 所谓虚拟存储器, 是指具有 <em>请求调⼊功能</em> 和 <em>置换功能</em>, 能 <em>从逻辑上对内存容量加以扩充</em> 的⼀种存储器系统. 其 <em>逻辑容量由内存容量和外存容量之和</em> 所决定, 其运⾏速度接近于内存速度, ⽽每位的成本却又接近于外存. 可见, 虚拟存储技术是⼀种性能⾮常优越的存储器管理技术, 故被⼴泛地应⽤于⼤、 中、⼩型机器和微型机中.</p>
<p><span class="link local"><a href="/408/operating-system/请求分页系统.html" title="请求分页系统 [408/operating-system/请求分页系统]">请求分页系统</a></span> 和 <span class="link local"><a href="/408/operating-system/请求分段系统.html" title="请求分段系统 [408/operating-system/请求分段系统]">请求分段系统</a></span> 是在 <span class="link local"><a href="/408/operating-system/分页存储管理⽅式.html" title="分页存储管理⽅式 [408/operating-system/分页存储管理⽅式]">分页系统</a></span> 和 <span class="link local"><a href="/408/operating-system/分段存储管理⽅式.html" title="分段存储管理⽅式 [408/operating-system/分段存储管理⽅式]">分段系统</a></span> 的基础上, 增加了请求调页 / 调段及分段置换功能后所形成的页式 / 段式虚拟存储系统.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-请求分页系统"><header><h1><span class="taxon"></span>请求分页系统 <a class="slug" href="/408/operating-system/请求分页系统.html">[请求分页系统]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/请求分页系统.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>状态位: 该页是否在内存
外存地址: 该页在外存对换区中的存储地址
访问位: 该页在一段时间内被访问的次数或未被访问的时间
修改位: 该页在内存中是否被修改过</p>
<p style="text-align: center;"><img src="../../assets/请求分页中的地址变换过程.png" style="border-radius: 0.2em; width: 500px;"></p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-请求分段系统"><header><h1><span class="taxon"></span>请求分段系统 <a class="slug" href="/408/operating-system/请求分段系统.html">[请求分段系统]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/请求分段系统.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary></details></section></p>
<p>在进程运⾏过程中, 若其所要访问的页⾯不在内存, ⽽需把它们调⼊内存, 但内存已⽆空闲空间时, 为了保证该进程能正常运⾏, 系统必须从内存中调出⼀页程序或数据送到磁盘的对换区中. 但应将哪个页⾯调出, 须根据⼀定的算法来确定. 通常, 把选择换出页⾯的算法称为 <span class="link local"><a href="/408/operating-system/页⾯置换算法.html" title="页⾯置换算法 [408/operating-system/页⾯置换算法]">页⾯置换算法</a></span> [Page-Replacement Algorithms]. 置换算法的好坏将直接影响到系统的性能.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-页⾯置换算法"><header><h1><span class="taxon"></span>页⾯置换算法 <a class="slug" href="/408/operating-system/页⾯置换算法.html">[页⾯置换算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/页⾯置换算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-抖动"><header><h1><span class="taxon"></span>抖动 <a class="slug" href="/408/operating-system/抖动.html">[抖动]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/抖动.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>不适当的算法可能会导致进程发⽣ “抖动” (Thrashing), 即刚被换出的页很快又要被访问, 需要将它重新调⼊, 此时又需要再选⼀页调出; ⽽此刚被调出的页很快又被访问, 又需将它调⼊, 如此频繁地更换页⾯, 以致⼀个进程在运⾏中把⼤部分时间都花费在页⾯置换⼯作上, 我们称该进程发⽣了 “抖动”.</p>
</details></section></p>
<p><span class="link local"><a href="/408/operating-system/最佳置换算法.html" title="最佳置换算法 OPT [408/operating-system/最佳置换算法]">最佳置换算法</a></span> 和 <span class="link local"><a href="/408/operating-system/先进先出置换算法.html" title="先进先出置换算法 FIFO [408/operating-system/先进先出置换算法]">先进先出置换算法</a></span> 是两种⽐较极端的算法. <span class="link local"><a href="/408/operating-system/最佳置换算法.html" title="最佳置换算法 OPT [408/operating-system/最佳置换算法]">最佳置换算法</a></span> 是⼀种理想化的算法, 它具有最好的性能, 但实际上是⽆法实现的. 通常使⽤ <span class="link local"><a href="/408/operating-system/最佳置换算法.html" title="最佳置换算法 OPT [408/operating-system/最佳置换算法]">最佳置换算法</a></span> 作为标准, 来评价其它算法的优劣. <span class="link local"><a href="/408/operating-system/先进先出置换算法.html" title="先进先出置换算法 FIFO [408/operating-system/先进先出置换算法]">先进先出置换算法</a></span> 是最直观的算法, 由于与通常页⾯的使⽤规律不符, 可能是性能最差的算法, 故实际应⽤极少.</p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-最佳置换算法"><header><h1><span class="taxon"></span>最佳置换算法 OPT <a class="slug" href="/408/operating-system/最佳置换算法.html">[最佳置换算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/最佳置换算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>最佳置换算法是由 Belady 于 1966 年提出的⼀种理论上的算法. 其所选择的被淘汰页⾯将是以后永不使⽤的, 或许是在最长 (未来) 时间内不再被访问的页⾯. 采⽤最佳置换算法通常可保证获得最低的缺页率. 但由于⼈们⽬前还⽆法预知,⼀个进程在内存的若⼲个页⾯中, 哪⼀个页⾯是未来最长时间内不再被访问的, 因⽽该算法是⽆法实现的, 但可以利⽤该算法去评价其它算法.</p>
<p style="text-align: center;"><img src="../../assets/利⽤最佳页⾯置换算法时的置换图.png" style="border-radius: 0.2em; width: 500px;"></p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-先进先出置换算法"><header><h1><span class="taxon"></span>先进先出置换算法 FIFO <a class="slug" href="/408/operating-system/先进先出置换算法.html">[先进先出置换算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/先进先出置换算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>FIFO 算法是最早出现的置换算法. 该算法总是淘汰最先进⼊内存的页⾯, 即选择在内存中驻留时间最久的页⾯予以淘汰. 该算法实现简单, 只需把⼀个进程已调⼊内存的页⾯按先后次序链接成⼀个队列, 并设置⼀个指针, 称为替换指针, 使它总是指向最⽼的页⾯. 但该算法与进程实际运⾏的规律不相适应, 因为在进程中, 有些页⾯经常被访问, ⽐如, 含有全局变量、常⽤函数、例程等的页⾯, FIFO 算法并不能保证这些页⾯不被淘汰.</p>
<p style="text-align: center;"><img src="../../assets/利⽤ FIFO 置换算法时的置换图.png" style="border-radius: 0.2em; width: 500px;"></p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-最近最久未使用"><header><h1><span class="taxon"></span>最近最久未使用算法 LRU <a class="slug" href="/408/operating-system/最近最久未使用.html">[最近最久未使用]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/最近最久未使用.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>最近最久未使⽤ LRU 的页⾯置换算法是根据页⾯谓⼊内存后的使⽤情况做出决策的. 由于⽆法预测各页⾯将来的使⽤情况, 只能利⽤“最近的过去” 作为 “最近的将来” 的近似, 因此, LRU 置换算法是选择最近最久未使⽤的页⾯予以淘汰. 该算法赋予每个页⾯⼀个访问字段,⽤来记录⼀个页⾯⾃上次被访问以来所经历的时间 $t$. 当需淘汰⼀个页⾯时, 选择现有页⾯中其 $t$ 值最⼤的, 即最近最久未使⽤的页⾯予以淘汰.</p>
<p style="text-align: center;"><img src="../../assets/LRU 页⾯置换算法.png" style="border-radius: 0.2em; width: 500px;"></p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-最少使用置换算法"><header><h1><span class="taxon"></span>最少使用置换算法 LFU <a class="slug" href="/408/operating-system/最少使用置换算法.html">[最少使用置换算法]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/最少使用置换算法.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><style>
hint {
  color: gray;  
}
em {
  color: rgb(249, 117, 131);
  font-style: normal;
}
</style>
<p>在采⽤最少使⽤置换算法 LFU 算法时, 应为在内存中的每个页⾯设置⼀个移位寄存器, ⽤来记录该页⾯被访问的频率.</p>
<p>该置换算法选择 <em>在最近时期使⽤最少的页⾯作为淘汰页</em>. 由于存储器具有较⾼的访向速度, 例如 100ns, 在 1ms 时间内可能对某页⾯连续访问成千上万次, 因此,直接利⽤计数器来记录某页被访问的次数是不现实的, 只能采⽤较⼤的时间间隔来记录对存储器某页的访问. 在最少使⽤置换算法中采⽤了移位寄存器⽅式. 每次访问某页时, 便将该移位寄存器的最⾼位置 1, 再每隔⼀定时间 (例如 100ms) 右移⼀次. 这样, 在最近⼀段时间使⽤最少的页⾯将是 $\sum_i R_i$ 最⼩的页.</p>
</details></section></p>
<p><section class="block hide-metadata" data-taxon=""><details open><summary id="408-operating-system-页⾯置换算法操作"><header><h1><span class="taxon"></span>页⾯置换算法操作 <a class="slug" href="/408/operating-system/页⾯置换算法操作.html">[页⾯置换算法操作]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/408/operating-system/页⾯置换算法操作.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></summary><p>针对应试, 我们总结 <span class="link local"><a href="/408/operating-system/最佳置换算法.html" title="最佳置换算法 OPT [408/operating-system/最佳置换算法]">最佳置换 OPT</a></span>, <span class="link local"><a href="/408/operating-system/先进先出置换算法.html" title="先进先出置换算法 FIFO [408/operating-system/先进先出置换算法]">先进先出置换 FIFO</a></span>, <span class="link local"><a href="/408/operating-system/最近最久未使用.html" title="最近最久未使用 LRU [408/operating-system/最近最久未使用]">最近最久未使用 LRU</a></span> 的操作流程.</p>
<p>所有页⾯置换算法操作都是先把页面数 $n$ 填满, 此时必定发生 $n$ 次中断, 内存中的页面序列记为 $S$.</p>
<ul>
<li><p>最佳置换 OPT: 最佳假设了知道未来页面的访问情况, 即走向. 因此所要做的策略是, 如果所要访问的页⾯ $p$ 不在内存 $S$. 则将 $S$ 中的 $n$ 个页面按序与未来的页面序列 $T$ 比较, 选择第一次出现但是最远的 $q \in S, q \in T$, 替换 $q$ 为 $p$.</p>
</li>
<li><p>先进先出置换 FIFO: FIFO 与 OPT 完全相反, 其替换过去访问且在 $S$ 中的最远的 $q$ 为所要访问的页⾯ $p$.</p>
</li>
<li><p>最近最久未使用 LRU: 选择最近最久未使⽤的页⾯ $q$ 予以淘汰 $q \to p$, 即 $S$ 序列完整出现在过去访问的第一个页面 $q$.</p>
</li>
</ul>
</details></section></p>
</details></section></p>
</details></section></p>
</details></section><footer><section class="block"><details open><summary><header><h1>Backlinks</h1></header></summary><section class="block" data-taxon="" style="margin-bottom: 0.4em;"><header><h1><span class="taxon"></span>索引 <a class="slug" href="/index.html">[index]</a><a class="slug" href="vscode://file:/Users/kokic/Repos/notes/index.md">[edit]</a></h1><div class="metadata"><ul></ul></div></header></section></details></section></footer></article>

<nav id="toc"><div class="block"><h1>Table of Contents</h1><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/引论.html" title="引论 [408/operating-system/引论]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-引论'"><span class="taxon"></span>引论</span></li><li class=""><a class="bullet" href="/408/operating-system/进程.html" title="进程 [408/operating-system/进程]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-进程'"><span class="taxon"></span>进程</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/进程控制块.html" title="进程控制块 PCB [408/operating-system/进程控制块]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-进程控制块'"><span class="taxon"></span>进程控制块 PCB</span></li><li class=""><a class="bullet" href="/408/operating-system/七态模型及调度.html" title="七态模型及调度 [408/operating-system/七态模型及调度]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-七态模型及调度'"><span class="taxon"></span>七态模型及调度</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/进程的结构.html" title="进程的结构 [408/operating-system/进程的结构]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-进程的结构'"><span class="taxon"></span>进程的结构</span></li><li class=""><a class="bullet" href="/408/operating-system/中断和异常.html" title="中断和异常 [408/operating-system/中断和异常]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-中断和异常'"><span class="taxon"></span>中断和异常</span></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/内核.html" title="内核 [408/operating-system/内核]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-内核'"><span class="taxon"></span>内核</span></li><li class=""><a class="bullet" href="/408/operating-system/进程同步机制.html" title="进程同步机制 [408/operating-system/进程同步机制]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-进程同步机制'"><span class="taxon"></span>进程同步机制</span></li><li class=""><a class="bullet" href="/408/operating-system/信号量机制.html" title="信号量机制 [408/operating-system/信号量机制]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-信号量机制'"><span class="taxon"></span>信号量机制</span></li><li class=""><a class="bullet" href="/408/operating-system/经典的进程同步问题.html" title="经典的进程同步问题 [408/operating-system/经典的进程同步问题]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-经典的进程同步问题'"><span class="taxon"></span>经典的进程同步问题</span></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/处理机调度与死锁.html" title="处理机调度与死锁 [408/operating-system/处理机调度与死锁]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-处理机调度与死锁'"><span class="taxon"></span>处理机调度与死锁</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/处理机调度.html" title="处理机调度 [408/operating-system/处理机调度]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-处理机调度'"><span class="taxon"></span>处理机调度</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/处理机调度层次.html" title="处理机调度层次 [408/operating-system/处理机调度层次]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-处理机调度层次'"><span class="taxon"></span>处理机调度层次</span></li><li class=""><a class="bullet" href="/408/operating-system/处理机调度策略准则.html" title="处理机调度策略准则 [408/operating-system/处理机调度策略准则]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-处理机调度策略准则'"><span class="taxon"></span>处理机调度策略准则</span></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/作业.html" title="作业 [408/operating-system/作业]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-作业'"><span class="taxon"></span>作业</span></li><li class=""><a class="bullet" href="/408/operating-system/调度算法.html" title="调度算法 [408/operating-system/调度算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-调度算法'"><span class="taxon"></span>调度算法</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/先来先服务.html" title="先来先服务 [408/operating-system/先来先服务]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-先来先服务'"><span class="taxon"></span>先来先服务</span></li><li class=""><a class="bullet" href="/408/operating-system/短作业优先.html" title="短作业优先 [408/operating-system/短作业优先]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-短作业优先'"><span class="taxon"></span>短作业优先</span></li><li class=""><a class="bullet" href="/408/operating-system/优先级调度算法.html" title="优先级调度算法 [408/operating-system/优先级调度算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-优先级调度算法'"><span class="taxon"></span>优先级调度算法</span></li><li class=""><a class="bullet" href="/408/operating-system/高响应比优先.html" title="高响应比优先 [408/operating-system/高响应比优先]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-高响应比优先'"><span class="taxon"></span>高响应比优先</span></li><li class=""><a class="bullet" href="/408/operating-system/时间片轮转.html" title="时间片轮转 [408/operating-system/时间片轮转]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-时间片轮转'"><span class="taxon"></span>时间片轮转</span></li><li class=""><a class="bullet" href="/408/operating-system/调度算法-例.html" title="调度算法 [408/operating-system/调度算法-例]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-调度算法-例'"><span class="taxon">Example. </span>调度算法</span></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/死锁.html" title="死锁 [Deadlock] [408/operating-system/死锁]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-死锁'"><span class="taxon"></span>死锁</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/死锁的原因.html" title="死锁的原因 [408/operating-system/死锁的原因]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-死锁的原因'"><span class="taxon"></span>死锁的原因</span></li><li class=""><a class="bullet" href="/408/operating-system/死锁产生的必要条件.html" title="死锁产生的必要条件 [408/operating-system/死锁产生的必要条件]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-死锁产生的必要条件'"><span class="taxon"></span>死锁产生的必要条件</span></li><li class=""><a class="bullet" href="/408/operating-system/死锁的处理策略.html" title="死锁的处理策略 [408/operating-system/死锁的处理策略]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-死锁的处理策略'"><span class="taxon"></span>死锁的处理策略</span></li><li class=""><a class="bullet" href="/408/operating-system/处理死锁的⽅法.html" title="处理死锁的⽅法 [408/operating-system/处理死锁的⽅法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-处理死锁的⽅法'"><span class="taxon"></span>处理死锁的⽅法</span></li><li class=""><a class="bullet" href="/408/operating-system/银行家算法.html" title="银行家算法 [408/operating-system/银行家算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-银行家算法'"><span class="taxon"></span>银行家算法</span></li></ul></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/存储器管理.html" title="存储器管理 [408/operating-system/存储器管理]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-存储器管理'"><span class="taxon"></span>存储器管理</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/存储器的层次结构.html" title="存储器的层次结构 [408/operating-system/存储器的层次结构]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-存储器的层次结构'"><span class="taxon"></span>存储器的层次结构</span></li><li class=""><a class="bullet" href="/408/operating-system/装入和链接.html" title="程序的装入和链接 [408/operating-system/装入和链接]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-装入和链接'"><span class="taxon"></span>程序的装入和链接</span></li><li class=""><a class="bullet" href="/408/operating-system/连续分配存储管理.html" title="连续分配存储管理⽅式 [408/operating-system/连续分配存储管理]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-连续分配存储管理'"><span class="taxon"></span>连续分配存储管理⽅式</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/单⼀连续分配.html" title="单⼀连续分配 [408/operating-system/单⼀连续分配]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-单⼀连续分配'"><span class="taxon"></span>单⼀连续分配</span></li><li class=""><a class="bullet" href="/408/operating-system/固定分区分配.html" title="固定分区分配 [408/operating-system/固定分区分配]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-固定分区分配'"><span class="taxon"></span>固定分区分配</span></li><li class=""><a class="bullet" href="/408/operating-system/动态分区.html" title="动态分区 [408/operating-system/动态分区]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-动态分区'"><span class="taxon"></span>动态分区</span></li><li class=""><a class="bullet" href="/408/operating-system/动态可重定位分区.html" title="动态可重定位分区分配 [408/operating-system/动态可重定位分区]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-动态可重定位分区'"><span class="taxon"></span>动态可重定位分区分配</span></li><li class=""><a class="bullet" href="/408/operating-system/连续分配存储管理⽅式-例.html" title="连续分配存储管理 [408/operating-system/连续分配存储管理⽅式-例]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-连续分配存储管理⽅式-例'"><span class="taxon">Example. </span>连续分配存储管理</span></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/离散分配.html" title="离散分配 [408/operating-system/离散分配]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-离散分配'"><span class="taxon"></span>离散分配</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/分页存储管理⽅式.html" title="分页存储管理⽅式 [408/operating-system/分页存储管理⽅式]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-分页存储管理⽅式'"><span class="taxon"></span>分页存储管理⽅式</span></li><li class=""><a class="bullet" href="/408/operating-system/分段存储管理⽅式.html" title="分段存储管理⽅式 [408/operating-system/分段存储管理⽅式]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-分段存储管理⽅式'"><span class="taxon"></span>分段存储管理⽅式</span></li><li class=""><a class="bullet" href="/408/operating-system/段页式存储管理⽅式.html" title="段页式存储管理⽅式 [408/operating-system/段页式存储管理⽅式]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-段页式存储管理⽅式'"><span class="taxon"></span>段页式存储管理⽅式</span></li></ul></li></ul></li><li class=""><a class="bullet" href="/408/operating-system/虚拟存储器.html" title="虚拟存储器 [408/operating-system/虚拟存储器]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-虚拟存储器'"><span class="taxon"></span>虚拟存储器</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/常规存储器管理⽅式的特征.html" title="常规存储器管理⽅式的特征 [408/operating-system/常规存储器管理⽅式的特征]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-常规存储器管理⽅式的特征'"><span class="taxon"></span>常规存储器管理⽅式的特征</span></li><li class=""><a class="bullet" href="/408/operating-system/请求分页系统.html" title="请求分页系统 [408/operating-system/请求分页系统]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-请求分页系统'"><span class="taxon"></span>请求分页系统</span></li><li class=""><a class="bullet" href="/408/operating-system/请求分段系统.html" title="请求分段系统 [408/operating-system/请求分段系统]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-请求分段系统'"><span class="taxon"></span>请求分段系统</span></li><li class=""><a class="bullet" href="/408/operating-system/页⾯置换算法.html" title="页⾯置换算法 [408/operating-system/页⾯置换算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-页⾯置换算法'"><span class="taxon"></span>页⾯置换算法</span><ul class="block"><li class=""><a class="bullet" href="/408/operating-system/抖动.html" title="抖动 [408/operating-system/抖动]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-抖动'"><span class="taxon"></span>抖动</span></li><li class=""><a class="bullet" href="/408/operating-system/最佳置换算法.html" title="最佳置换算法 OPT [408/operating-system/最佳置换算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-最佳置换算法'"><span class="taxon"></span>最佳置换算法 OPT</span></li><li class=""><a class="bullet" href="/408/operating-system/先进先出置换算法.html" title="先进先出置换算法 FIFO [408/operating-system/先进先出置换算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-先进先出置换算法'"><span class="taxon"></span>先进先出置换算法 FIFO</span></li><li class=""><a class="bullet" href="/408/operating-system/最近最久未使用.html" title="最近最久未使用 LRU [408/operating-system/最近最久未使用]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-最近最久未使用'"><span class="taxon"></span>最近最久未使用算法 LRU</span></li><li class=""><a class="bullet" href="/408/operating-system/最少使用置换算法.html" title="最少使用置换算法 LFU [408/operating-system/最少使用置换算法]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-最少使用置换算法'"><span class="taxon"></span>最少使用置换算法 LFU</span></li><li class=""><a class="bullet" href="/408/operating-system/页⾯置换算法操作.html" title="页⾯置换算法操作 [408/operating-system/页⾯置换算法操作]">■</a><span class="link local" onclick="window.location.href='#408-operating-system-页⾯置换算法操作'"><span class="taxon"></span>页⾯置换算法操作</span></li></ul></li></ul></li></ul></div></nav></div></body></html>